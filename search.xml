<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java 中的集合</title>
      <link href="/2023/08/29/java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88/"/>
      <url>/2023/08/29/java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java 中的集合框架一直是 java 学习中的重中之重，以前的学习仅仅局限于皮毛，在阅读一些博客后有了新的体会，记录以便复习。</p><p>本文参考<a href="https://www.bilibili.com/video/BV1fh411y7R8?p=499">韩顺平的循序渐进学JAVA</a>、<a href="https://blog.csdn.net/feiyanaffection/article/details/81394745?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168774144216800211584849%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168774144216800211584849&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81394745-null-null.142%5Ev88%5Econtrol_2239%5Ev2%5Einsert_chatgpt&utm_term=java%E9%9B%86%E5%90%88&spm=1018.2226.3001.4187">java集合超详解</a>、<a href="https://blog.csdn.net/zdl66/article/details/126251818?ops_request_misc=&request_id=&biz_id=102&utm_term=java%E9%9B%86%E5%90%88&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-126251818.nonecase&spm=1018.2226.3001.4187">java集合（超详细）</a></p></blockquote><h2 id="集合介绍"><a href="#集合介绍" class="headerlink" title="集合介绍"></a>集合介绍</h2><h3 id="集合的概述"><a href="#集合的概述" class="headerlink" title="集合的概述"></a>集合的概述</h3><p>​所有的集合类和集合接口都在 java.util 包下，</p><p>集合和数组的区别</p><p>（1）长度的区别</p><ul><li>数组长度固定，定义长了会造成内存空间的浪费，定义短了不够用。</li><li>集合可以动态保存任意多个对象，使用比较方便</li></ul><p>（2）内容的区别</p><ul><li>数组可以存储基本数据类型和引用数据类型</li><li>集合中只能是引用数据类型（存储的为对象的内存地址）</li></ul><p>（3）元素的区别</p><ul><li>数组中只能存储同一类型成员</li><li>集合中可以存储不同类型的数据（一般情况下存储的是同一类型的数据）</li></ul><h2 id="集合的框架体系"><a href="#集合的框架体系" class="headerlink" title="集合的框架体系"></a>集合的框架体系</h2><p>java 中集合的分类有很多，大致分为两类：Collection（单列集合）和 Map（双列集合），它们下面又有许多子接口。通过 intellji 的 Dragrame 功能明显可以看到 Collection 是继承于 Iterable，Set 和 list 又继承 Collection，而 ArrayList、Vector、和 LinkedList 又实现了 List 接口，HashSet、TreeSet 又实现了 Set 接口。</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/16/64dcc7e5b5ad7.png" alt="Collection.png"></p><p>而 Map 接口下 又有 HashＭap、TreeMap、HashTbele</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/16/64dcc835dbd2e.png" alt="Map.png"></p><h3 id="Collection（单列集合）"><a href="#Collection（单列集合）" class="headerlink" title="Collection（单列集合）"></a>Collection（单列集合）</h3><p>（1）List 集合</p><p>​元素按先后进入顺序保存，可重复。</p><ul><li>ArrayList 接口实现类，数组，随机访问，没有同步，线程不安全</li><li>LinkedList 接口实现类，链表，插入删除，没有同步，线程不安全</li><li>Vector 接口实现类，数组，同步，线程安全<ul><li>Stack 是 Vector 接口的实现类</li></ul></li></ul><p>（2）Set 集合</p><p>​仅接收一次，不可重复，并做内部排序</p><ul><li>HashSet 使用 hash 表存储数据</li><li>TreeSet 底层实现为二叉树 ，元素排</li></ul><h2 id="Collection-的接口和方法"><a href="#Collection-的接口和方法" class="headerlink" title="Collection 的接口和方法"></a>Collection 的接口和方法</h2><p>Collection 接口实现类的特点<br>（1）Collection 实现子类可以存放多个元素，而且每个元素都可以是 Object。<br>（2）关于 Collection 的实现类，有些可以存放重复元素，有些则不可以。<br>（3）其次 Collection 的实现类，有些是有序的（List），有些不是有序的 (set)<br>（4）Collection 接口没有直接的实现子类，而是通过它的子接口（List）和（Set）来实现的。<br>这里我通过 ArrayList 来演示 Colllection 的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br></pre></td></tr></table></figure><ul><li>add 添加单个元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">list.add(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><ul><li>remove 删除指定元素，这里可以指定删除哪一个元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.remove(<span class="string">&quot;Tom&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>contains 查找元素是否存在，若元素存在则会返回 true，反之，则会返回 false.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.contains(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">list.contains(<span class="string">&quot;jack&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>size 获取元素个数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.size();</span><br></pre></td></tr></table></figure><ul><li>isEmpty: 判断是否为空</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.isEmpty();</span><br></pre></td></tr></table></figure><ul><li>clear 清空</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.clean();</span><br></pre></td></tr></table></figure><ul><li>addAll 添加多个元素，这里添加的是集合类型（Collection)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list2.add(<span class="string">&quot;三国演义&quot;</span>);</span><br><span class="line">list2.add(<span class="string">&quot;水浒传&quot;</span>);</span><br><span class="line">list.addAll(list2);<span class="comment">//直接添加的话，接在list的后面</span></span><br><span class="line">list.addAll(<span class="number">1</span>,list2);<span class="comment">//指定添加的顺序</span></span><br></pre></td></tr></table></figure><ul><li>containsAll 查找多个元素是否存在，同样参数是集合类型（Collection）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.containsAll(list2);</span><br></pre></td></tr></table></figure><ul><li>removeAll 删除多个元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.removeAll(list2);</span><br></pre></td></tr></table></figure><h2 id="Collection-接口的遍历方式"><a href="#Collection-接口的遍历方式" class="headerlink" title="Collection 接口的遍历方式"></a>Collection 接口的遍历方式</h2><h3 id="Iterator（迭代器）"><a href="#Iterator（迭代器）" class="headerlink" title="Iterator（迭代器）"></a>Iterator（迭代器）</h3><h4 id="Iterator-介绍"><a href="#Iterator-介绍" class="headerlink" title="Iterator 介绍"></a>Iterator 介绍</h4><ol><li><p>Iterator 对象称为迭代器，主要用于遍历 Collection 集合中的元素</p></li><li><p>所有实现了 Collection 接口的集合类都有一个 iterator() 方法，用来返回要给实现了 Iterator 接口的对象，既可以返回一个迭代器。</p></li><li><p>Iterator 仅用于遍历集合，Iterator 本身并不能存放对象。</p></li></ol><h4 id="迭代器的执行原理"><a href="#迭代器的执行原理" class="headerlink" title="迭代器的执行原理"></a>迭代器的执行原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line"> System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iterator 是得到的 Iterator 对象，<span style="color:blue">hasNext()</span>判断是否还有下一个元素，next 指针下移，下移后集合位置上的元素返回。</p><p>注意：在调用 iterator.next() 方法之前必须要调用 iterator.hasNext() 进行检验，若不调用，且下一条记录无效，直接调用 iterator.next() 就会抛出 NoSuchElmentException 异常。</p><p>idea 工具中快速生成迭代器的方式输入”itit“</p><h3 id="增强-for-循环"><a href="#增强-for-循环" class="headerlink" title="增强 for 循环"></a>增强 for 循环</h3><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>增强 for 循环就是简化版的 iterator，本质一样，只能用于遍历集合和数组。</p><p>基本语法</p><p>for（元素类型 元素名：集合名或数组名）{</p><p>访问元素</p><p>}</p><p>注意：</p><p>增强 for 循环底层仍然是迭代器</p><h2 id="List-接口和常用方法"><a href="#List-接口和常用方法" class="headerlink" title="List 接口和常用方法"></a>List 接口和常用方法</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>list 接口是 Collection 接口的子接口</p><p>List 集合类中的元素有序（即添加顺序和去除顺序一致），而且可以重复。</p><p>List 集合中的每一个元素都有其对应的顺序索引，即支持索引</p><h3 id="List-特有方法"><a href="#List-特有方法" class="headerlink" title="List 特有方法"></a>List 特有方法</h3><p>list 集合添加了根据索引来操作集合元素的方法</p><p>（1）void add(int index, Object obj) 在 index 的位置插入 obj 元素</p><p>（2）boolean addAll(int index, Colllection col) 从 index 位置开始将集合 col 中的所有元素添加进来</p><p>（3）Object get(int index) 获取 index 位置的元素</p><p>（4）int indexOf(Object obj) 返回 obj 在集合中首次出现的位置</p><p>（5）int lastOf(Object obj) 返回 obj 在集合中末次出现的位置</p><p>（6）Object remove(int index) 移除 index 位置的元素，并返回此元素</p><p>（7）Object set(int index, Object obj) 设置指定 index 位置的元素为 obj，相当于是置换</p><p>（8）List subList(int fromIndex, int toIndex) 返回 fromIndex 到 toIndex 位置的子集合</p><h3 id="List-的三种遍历方式"><a href="#List-的三种遍历方式" class="headerlink" title="List 的三种遍历方式"></a>List 的三种遍历方式</h3><ol><li><p>使用 Iterator</p></li><li><p>使用增强 for</p></li><li><p>使用普通 for</p></li></ol><h2 id="ArrayList-底层结构和源码分析"><a href="#ArrayList-底层结构和源码分析" class="headerlink" title="ArrayList 底层结构和源码分析"></a>ArrayList 底层结构和源码分析</h2><h3 id="ArrayList-的注意事项"><a href="#ArrayList-的注意事项" class="headerlink" title="ArrayList 的注意事项"></a>ArrayList 的注意事项</h3><p>ArrayList 可以加入 null，并且允许多个</p><p>ArrayList 是由数组来实现数据存储的</p><p>ArrayList 基本等同于 Vector，除了 ArrayList 是线程不安全的（执行效率高），多线程的情况下，不建议使用 ArrayList</p><p>add 方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    ensureCapcityInternal(size+<span class="number">1</span>);</span><br><span class="line">    elementData[size++] =e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList 扩容机制</p><ol><li><p>ArrayList 中维护了一个 Object 类型的数组 elementData.</p></li><li><p>当创建 ArrayList 对象时，如果使用的是无参构造器，则初始 elementData 容量为 0，第一次添加，则扩容 elmentData 为 10，如需要再次扩容，则扩容 elementData 为 1.5 倍。</p></li><li><p>如果使用的是指定大小的构造器，则初始 elementData 容量为指定容量大小，如果需要扩容，则直接扩容 elementData 为 1.5 倍</p></li></ol><p>第一步执行的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建了一个空的数据 elementData 数据 &#x3D;{}</p><p>第二步执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>执行 list.add</p><p>（1) 先确定是否要扩容</p><p>（2）在执行复制</p><p>再分析这个 ensureCapacityInternal() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该方法确定了 minCapacity</p><p>（1）第一次扩容为 10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>modCount 记录当前集合被修改次数，这里防止有多个线程同时去修改</p><p>minCapacity - elementData.length 当前我实际的数组的长度小于最小默认数组长度，就调用 grow() 方法去扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用扩容机制来确认要扩容到多大</p><p>第一次 newCapacity&#x3D;10</p><p>第二次以及其以后，按照 1.5 倍进行扩容</p><p>扩容使用的是 Array.copyof( )</p><p>当初始化 ArrayList 数组容量后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Vector-的基本介绍"><a href="#Vector-的基本介绍" class="headerlink" title="Vector 的基本介绍"></a>Vector 的基本介绍</h2><p>(1)Vector 类的定义说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstratList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;,RandomAccess,Cloneable,Serializable</span><br></pre></td></tr></table></figure><p>(2) Vector 底层是一个对象数组，protected Object elementData</p><p>(3) Vector 是线程同步的，即线程安全，Vector 的操作方法带有 synchronized</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> synchroized E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index&gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4) 在开发中，需要线程同步安全时，考虑使用 Vector</p><p>Vector 和 ArrayList 的比较</p><table><thead><tr><th></th><th>底层结构</th><th>线性安全，同步效率</th><th>版本</th><th>扩容倍数</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>不安全，效率高</td><td>jdk1.2</td><td>如果是有参构造，每次按 1.5 倍扩容。如果是无参构造，第一次容量变成 10，第二次按 1.5 倍扩容</td></tr><tr><td>Vector</td><td>可变数组</td><td>安全，效率不高</td><td>jdk1.0</td><td>如果是无参，默认容量为 10，满后按 2 倍扩容；如果指定大小，则每次直接按 2 倍扩容</td></tr></tbody></table><p>源码分析</p><p>无参构造：</p><p>第一步，按照默认的 10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第二步：</p><p>在使用 add 方法时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>记录操作数，然后与 ArrayList 的差不多，先确认是否需要扩容，进入<span style="color:blue">ensureCapacityHeLper</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>只有当容量满载时，才会去执行 grow 方法进行扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                        capacityIncrement : oldCapacity);</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedList-的底层机制"><a href="#LinkedList-的底层机制" class="headerlink" title="LinkedList 的底层机制"></a>LinkedList 的底层机制</h2><p>（1）Linked 底层实现了双向链表和双端队列的特点</p><p>（2）可以添加任意元素（元素可以重复），包括 null</p><p>（3）线程不安全，没有实现同步</p><p>LinkedList 的底层操作机制</p><p>（1）LinkedList 底层维护了一个双向链表</p><p>（2）LinkedList 中维护了两个属性 first 和 last 分别指向首节点和尾节点</p><p>（3）每个节点（Node 对象），里面由维护了 prey、next、item 三个属性，其中通过 prev 指向前一个，通过 next 指向后一个节点。最终实现双向链表</p><p>（4) 所以 LinkedList 的元素的添加和删除，不是通过数组完成的，相对来说效率较高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br></pre></td></tr></table></figure><p>实际上仅仅调用了它的无参构造器 <code>public LinkedList()&#123;&#125;</code> ，这时候 linkedList 的属性如下：</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/16/64dcc8ad813ee.png" alt="linkedList.png"></p><p>下一步执行 add() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着执行，将新的节点加入到双向链表的后面，我们看一下<span style="color:blue">linkLast(e)</span>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Links e as last element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在因为现在没有节点，l&#x3D;last&#x3D;null，之后创建了一个节点 node(l, e, null)，此时，因为只有只一个节点，所以 last&#x3D;newNode，first&#x3D;newNode, </p><p>ArrayList 和 LinkedList 的比较</p><table><thead><tr><th></th><th>底层结构</th><th>增删的效率</th><th>改查的效率</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>较低，数组扩容</td><td>较高</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>较高，通过链表追加</td><td>较低</td></tr></tbody></table><p>如何选择 ArrayList 和 LinkedList：</p><p>（1）如果我们的改查的操作多，选择 ArrayList</p><p>（2）如果我们增删的操作多，选择 LinkedList</p><p>（3）一般来说，在程序中，80%~90% 都是查询，因此大部分情况下会选择 ArrayList</p><p>（4）在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是 ArrayList，另外一个模块使用是 LinkedList</p><h2 id="Set-接口和常用方法"><a href="#Set-接口和常用方法" class="headerlink" title="Set 接口和常用方法"></a>Set 接口和常用方法</h2><p>（1）无序（添加和取出的顺序不一样），没有索引</p><p>（2）不允许重复元素，所以最多包含一个 null</p><p>set 常见的方法：</p><ul><li>boolean add(E e)——如果 set 中尚未存在指定的元素，则添加此元素。</li><li>boolean addAll</li><li>clear()</li><li>contains</li><li>containsAll</li><li>equals</li><li>hashCode</li><li>isEmpty</li><li>iterator</li><li>remove</li><li>removeAll</li><li>retainAll</li><li>size</li><li>toArray</li></ul><p>HashSet 的全面说明</p><p>HashSet 实现了 Set 接口，但 HashSet 实际上是 HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以存放 null 值，不能有重复值，所以只能有一个 null</p><p>HashSet 不保证元素是有序的 m，取决于 hash 后，再确认索引的结果</p><p> 根据前面所述，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;tom&quot;</span>));<span class="comment">//true</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;tom&quot;</span>));<span class="comment">//true</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;edu&quot;</span>));<span class="comment">//true</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;edu&quot;</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>HashSet 的底层机制是数组 + 链表 + 红黑树</p><ol><li><p>先取得获取元素的哈希值（hashCode 方法）</p></li><li><p>对哈希值进行运算，得出一个索引值即为存放再哈希表中的位置号</p></li><li><p>如果该位置上没有其他元素，则直接存放。如果该位置上已经有其他元素，则需要进行 equals 判断，如果相等，则不再添加。如果不想等，则以链表的方式添加。</p></li></ol><p>HashSet 底层机制说明</p><p>分析 HashSet 的添加元素是如何实现的 (hash()+equals( ))</p><ol><li><p>HashSet 底层是 HashMap</p></li><li><p>添加一个元素时，先得到 hash 值 - 会转换成 -&gt;索引值</p></li><li><p>找到存储数据表 table，看这个索引位置是否已经存放元素</p></li><li><p>如果没有，直接加入</p></li><li><p>如果有，调用 equals 比较，如果相同，就放弃添加，如果不相同，则添加到最后</p></li><li><p>在 Java8 中，如果一条链表的元素个数超过 TREEIFY_THRESHD（默认是 8)，并且 table 的大小，并且 table 的大小》&#x3D;MIN_TREEIFY_CAPACITY（默认 64)，就会进行树化</p></li><li><p>第一步首先执行 HashSet()</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>执行 add() 方法，这里<span style="color:blue">PRESENT</span>是一个空的对象数组，用来 HashMap(Key,Vaule) 中的 Vaule 占位。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e,PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>执行 put() 方法，该方法会执行 hash(key) 方法得到 key 对应的 hash 值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key,V value)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key),key,value,<span class="literal">false</span>,<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下 hash 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>执行 putVal() 方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;<span class="comment">//定义了辅助变量</span></span><br><span class="line">    <span class="comment">//table就是放Node&lt;K,V&gt;节点的一个数组。即table就是HashMap的一个数组，类型是Node[]</span></span><br><span class="line">    <span class="comment">//if语句表示如果当前table是null，或者大小=0</span></span><br><span class="line">    <span class="comment">//就是第一次扩容到16个空间</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//(1)根据Key,得到hash，去计算该key应该存放到table表的哪一个索引位置，并且把这个位置的对象，赋给p</span></span><br><span class="line">    <span class="comment">//(2)判断p是否为空，</span></span><br><span class="line">    <span class="comment">//(2.1)如果p为空，表示还没有存放元素，就创建一个Node</span></span><br><span class="line">    <span class="comment">//(2.2)就放在该位置，tab[i]=newNode(hash,key,value,null)</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果当前索引对应的链表的第一个元素的值和要添加key的hash值相等</span></span><br><span class="line">            <span class="comment">//并且满足下面的两个条件之一</span></span><br><span class="line">            <span class="comment">//(1)准备加入的key和p指向的Node节点的key是同一个对象</span></span><br><span class="line">            <span class="comment">//(2)p指向的Node节点的key的equls()和准备加入的key比较后相同</span></span><br><span class="line">            <span class="comment">//就不能加入</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//再判断p是不是一颗红黑树</span></span><br><span class="line">            <span class="comment">//如果是一颗红黑树，就调用putTreeVal来进行添加</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//如果table对应的索引位置，已经是一个链表，就使用for循环比较</span></span><br><span class="line">                <span class="comment">//(1)依次和该链表的每一个元素比较后都不相同，则加入到该链表的最后</span></span><br><span class="line">                <span class="comment">//(2)依次和该链表的每一个元素比较过程中，如果有相同的情况，就直接break</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>hashSet 的练习思考题</p><p>定义一个 Employee 类，该类包括：private 成员属性 name，age 要求：</p><ol><li><p>创建 3 个 Employee 放入 HashSet 中</p></li><li><p>当 name 和 age 的值相同时候，认为是相同员工，不能添加到 HashSet 集合中</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新版Spring基础（spring6）</title>
      <link href="/2023/08/28/%E6%96%B0%E7%89%88Spring%E5%9F%BA%E7%A1%80%EF%BC%88spring6%EF%BC%89/"/>
      <url>/2023/08/28/%E6%96%B0%E7%89%88Spring%E5%9F%BA%E7%A1%80%EF%BC%88spring6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="技术体系结构"><a href="#技术体系结构" class="headerlink" title="技术体系结构"></a>技术体系结构</h2><p>首先我们来了解一下项目开发的两个架构：</p><ul><li><p>单—架构<br>一个项目，一个工程，导出为一个war包，在一个Tomcat 上运行。</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/28/64ec5122cda32.png" alt="image-20230828154738332"></p><p>单一架构，项目主要应用的技术框架为</p></li></ul><h2 id="SpringFramework介绍"><a href="#SpringFramework介绍" class="headerlink" title="SpringFramework介绍"></a>SpringFramework介绍</h2><h2 id="SpringIoc容器和核心概念"><a href="#SpringIoc容器和核心概念" class="headerlink" title="SpringIoc容器和核心概念"></a>SpringIoc容器和核心概念</h2><h2 id="SpringIoc实践和应用"><a href="#SpringIoc实践和应用" class="headerlink" title="SpringIoc实践和应用"></a>SpringIoc实践和应用</h2><h3 id="Spring-IoC-x2F-DI-实现步骤"><a href="#Spring-IoC-x2F-DI-实现步骤" class="headerlink" title="Spring IoC&#x2F;DI 实现步骤"></a>Spring IoC&#x2F;DI 实现步骤</h3><h3 id="基于XML配置方式组件管理"><a href="#基于XML配置方式组件管理" class="headerlink" title="基于XML配置方式组件管理"></a>基于XML配置方式组件管理</h3><h4 id="组件-Bean-信息声明配置-IoC"><a href="#组件-Bean-信息声明配置-IoC" class="headerlink" title="组件(Bean)信息声明配置(IoC)"></a>组件(Bean)信息声明配置(IoC)</h4><ol><li>目标</li><li>思路</li><li>准备项目</li><li></li></ol><h4 id="组件-Bean-依赖注入配置-DI"><a href="#组件-Bean-依赖注入配置-DI" class="headerlink" title="组件(Bean)依赖注入配置(DI)"></a>组件(Bean)依赖注入配置(DI)</h4><h4 id="Ioc容器创建和使用"><a href="#Ioc容器创建和使用" class="headerlink" title="Ioc容器创建和使用"></a>Ioc容器创建和使用</h4><h4 id="高级特性：组件-Bean-作用域和周期方法配置"><a href="#高级特性：组件-Bean-作用域和周期方法配置" class="headerlink" title="高级特性：组件(Bean)作用域和周期方法配置"></a>高级特性：组件(Bean)作用域和周期方法配置</h4><h4 id="高级特性：FactoryBean特性和使用"><a href="#高级特性：FactoryBean特性和使用" class="headerlink" title="高级特性：FactoryBean特性和使用"></a>高级特性：FactoryBean特性和使用</h4><h4 id="基于XML方式整合三层架构组件"><a href="#基于XML方式整合三层架构组件" class="headerlink" title="基于XML方式整合三层架构组件"></a>基于XML方式整合三层架构组件</h4><h2 id="Spring-AOP-面向切面编程"><a href="#Spring-AOP-面向切面编程" class="headerlink" title="Spring AOP 面向切面编程"></a>Spring AOP 面向切面编程</h2><h2 id="Spring-声明式事务"><a href="#Spring-声明式事务" class="headerlink" title="Spring 声明式事务"></a>Spring 声明式事务</h2>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql复习梳理</title>
      <link href="/2023/08/17/mysql%E5%A4%8D%E4%B9%A0%E6%A2%B3%E7%90%86/"/>
      <url>/2023/08/17/mysql%E5%A4%8D%E4%B9%A0%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h2><h3 id="什么是数据库-1"><a href="#什么是数据库-1" class="headerlink" title="什么是数据库"></a>什么是数据库</h3><p>数据库（DB,DateBase）</p><p>概念：数据仓库，软件，安装在操作系统（windows，linux，mac）上！SQL，可以存储大量的数据</p><p>作用：存储数据，管理数据</p><h3 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h3> <mark class="hl-label blue">关系型数据库(ROBMS)</mark> ：<ul><li>MySQL、Oracle、Sql Server、DB2、SQLite</li><li>通过表和表之间，行和列之间的关系进行数据的存储，通过二维表来表示数据之间的联系，二维表的每一行表示一条数据。例如：学员信息表、考勤表…..</li></ul><mark class="hl-label orange">非关系型数据库(NON-ROBMS)</mark> ：<ul><li>Redis、MongDB</li><li>非关系型数据库、对象存储，通过对象的自身的属性来决定。</li></ul><p>DBMS（数据库管理系统）</p><ul><li>数据库的管理软件，科学有效的管理我们的数据，维护和获取数据；</li><li>MySQL，数据库管理系统</li></ul><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><h3 id="基本的操作"><a href="#基本的操作" class="headerlink" title="基本的操作"></a>基本的操作</h3><mark class="hl-label blue">命令行连接</mark> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>proot  <span class="comment">-- 连接数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> mysql.user <span class="keyword">set</span> authentication_string<span class="operator">=</span>password(<span class="string">&#x27;123456&#x27;</span>) <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span> <span class="keyword">and</span> Host<span class="operator">=</span><span class="string">&#x27;localhost&#x27;</span>; <span class="comment">-- 修改用户权限</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> databases;  <span class="comment">-- 查看所有的数据库</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> use school  <span class="comment">-- 切换数据库 use 数据库名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> tables;<span class="comment">-- 查看数据库中所有的表</span></span><br><span class="line"><span class="keyword">describe</span> student; <span class="comment">-- 显示数据库中所有的表的信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database westos;   <span class="comment">-- 创建一个数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 单行注释（SQL的本来的注释）</span></span><br><span class="line"><span class="comment">/*  （sql的多行注释）</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">ssss</span></span><br><span class="line"><span class="comment">xxxxx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>操作数据库&gt;操作数据库中的表&gt;操作数据库中表的数据</p><mark class="hl-label pink">mysql关键字不区分大小写</mark> <p>1、创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] westos;</span><br></pre></td></tr></table></figure><p>2、删除数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] westos;</span><br></pre></td></tr></table></figure><p>3、使用数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE `school`   <span class="comment">-- 如果你的表名或者字段名是一个特殊字符，就需要带``</span></span><br></pre></td></tr></table></figure><p>4、查看数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES; <span class="comment">-- 查看所有的数据库</span></span><br></pre></td></tr></table></figure><h3 id="数据库的列类型"><a href="#数据库的列类型" class="headerlink" title="数据库的列类型"></a>数据库的列类型</h3><blockquote><p>数值</p></blockquote><ul><li><p>tinyint   十分小的数据 1个字节</p></li><li><p>smallint  较小的数据        2个字节</p></li><li><p>mediumint   中等大小的数据  3个字节</p></li><li><p>int      标准的整数                 4个字节</p></li><li><p>bigint    较大的数据              8个字节</p></li><li><p>float      浮点数              4个字节</p></li><li><p>double   浮点数             8 个字节</p></li><li><p>decimal   字符串形式的浮点数</p></li></ul><blockquote><p>字符串</p></blockquote><ul><li><p>char  字符串固定大小的  0~255</p></li><li><p>varchar   可变字符串    0~65535    常用的变量    String</p></li><li><p>tinyint      微型文本     2^8-1</p></li><li><p>text           文本串    2^16-1      保存大文本</p></li></ul><blockquote><p>时间日期</p></blockquote><p>java.util,Date</p><ul><li>date YYYY-MM-DD，日期格式</li><li>time         HH:mm:ss      时间格式</li><li>datetime   YYYY-MM-DD  HH:mm:ss     最常用的时间格式</li><li>timestamp  时间戳，1970.1.1到现在的毫秒数</li><li>year   年份表示</li></ul><blockquote><p>null</p></blockquote><ul><li>没有值，未知</li><li><mark class="hl-label red">注意，不要使用NULL进行运算。结果为NULL</mark> </li></ul><h3 id="数据库的字段属性-重点"><a href="#数据库的字段属性-重点" class="headerlink" title="数据库的字段属性(重点)"></a>数据库的字段属性(重点)</h3><p>Unsigned:</p><ul><li>无符号的整数</li><li>声明了该列不能声明为负数</li></ul><p>zerofill:</p><ul><li>0填充的</li><li>不足位数，使用0来填充 ，int（3） ，5  –   005</li></ul><p>自增：</p><ul><li>通常理解为自增，自动在上一条记录的基础上加1（默认）</li><li>通常用来设计唯一的主键~index，必须是整数类型</li><li>可以自定义设计主键自增的起始值和步长</li></ul><p>非空   NULL not  null</p><ul><li>假设设置为not null，如果不给它赋值，就会报错！</li><li>NULL，如果不填写值，就是null</li></ul><p>默认：</p><ul><li>设置默认的值，如果不指定该列的值，则会有默认的值！</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 每一个表，都必须存在以下五个字段</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">id   主键</span></span><br><span class="line"><span class="comment">`version` 乐观锁</span></span><br><span class="line"><span class="comment">is_delete  伪删除</span></span><br><span class="line"><span class="comment">gmt_create  创建时间</span></span><br><span class="line"><span class="comment">gmt_update  修改时间</span></span><br></pre></td></tr></table></figure><h3 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><p>​实例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 目标：创建一个school数据库</span></span><br><span class="line"><span class="comment">-- 创建学生表（列，字段）使用SQL创建</span></span><br><span class="line"><span class="comment">-- 学号int 登录密码varchar(20) 姓名，性别varchar(2)，出生日期（datetime)，家庭地址，email</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `student`(</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;匿名&#x27;</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  `pwd` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;123456&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `sex` <span class="type">VARCHAR</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;女&#x27;</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">  `birthday` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;出生日期&#x27;</span>,</span><br><span class="line">  `address` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;家庭住址&#x27;</span>,</span><br><span class="line">  `emial` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(`id`)</span><br><span class="line">  )ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8; </span><br></pre></td></tr></table></figure><p>格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] `表名`(</span><br><span class="line"><span class="string">&#x27;字段名&#x27;</span> 列类型 [属性][索引][注释],</span><br><span class="line">    <span class="string">&#x27;字段名&#x27;</span> 列类型 [属性][索引][注释],</span><br><span class="line">    ......</span><br><span class="line">    <span class="string">&#x27;字段名&#x27;</span> 列类型 [属性][索引][注释] </span><br><span class="line">)[表类型][字符集设置][注释]</span><br></pre></td></tr></table></figure><p>常用的命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE school; <span class="comment">-- 查看创建数据库的语句</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student; <span class="comment">-- 查看student数据表的定义语句</span></span><br><span class="line"><span class="keyword">DESC</span> student; <span class="comment">-- 显示表的结构</span></span><br></pre></td></tr></table></figure><h3 id="数据表的类型"><a href="#数据表的类型" class="headerlink" title="数据表的类型"></a>数据表的类型</h3><p>关于数据库引擎，INNODB默认使用，MYISAM早些年使用的</p><table><thead><tr><th></th><th>MYISAM</th><th>INNODB</th></tr></thead><tbody><tr><td>事务支持</td><td>不支持</td><td>支持</td></tr><tr><td>数据行锁定</td><td>不支持</td><td>支持</td></tr><tr><td>外键约束</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr><tr><td>表的空间大小</td><td>较小</td><td>较大，约为两倍</td></tr></tbody></table><p>常规的使用操作：</p><ul><li>MYISAM 节约空间，速度较快</li><li>INNODB  安全性高，事务的处理，多表多用户操作</li></ul><blockquote><p>在物理空间存在的位置</p></blockquote><p>所有的数据库文件都存在data目录下，本质还是文件的存储</p><p>MySQL引擎在物理文件上的区别</p><ul><li>InnoDB在数据表中只有一个*.frm 文件，以及上级目录下的ibdata1文件 </li><li>MYISAM对应文件<ul><li>*.frm表结构的定义文件</li><li>*.MYD        数据文件（data)</li><li>*.MYI          索引文件（index)</li></ul></li></ul><blockquote><p>设置数据库表中的字符集编码</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure><p>不设置的话，会是MySQL默认的字符集编码（不支持中文）</p><p>MySQL的默认编码是Latin1，不支持中文</p><p>在my.ini配置默认的编码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">charset<span class="operator">-</span><span class="keyword">set</span><span class="operator">-</span>server<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure><h3 id="修改删除表"><a href="#修改删除表" class="headerlink" title="修改删除表"></a>修改删除表</h3><mark class="hl-label red">修改</mark> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改表名 : ALTER TABLE 旧表名 RENAME AS 新表名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> teacher RENAME <span class="keyword">AS</span> teacher1</span><br><span class="line"><span class="comment">-- 增加表的字段：ALTER TABLE 表名 ADD 字段名 列属性</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> teacher1 <span class="keyword">ADD</span> age <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表的字段（重命名 ，修改约束）</span></span><br><span class="line"><span class="comment">-- ALTER TABLE 表名 MODIFY 字段名 列属性[]</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> teacher1 MODIFY age <span class="type">VARCHAR</span>(<span class="number">11</span>)  <span class="comment">--修改约束</span></span><br><span class="line"><span class="comment">-- ALTER TABLE 表名 CHANGE 旧名字 新名字 列属性[]</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> teacher1 CHANGE age age1 <span class="type">INT</span>(<span class="number">1</span>) <span class="comment">-- 字段重命名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表的字段 ALTER TABLE　表名 DROP 字段名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> teacher1 <span class="keyword">DROP</span>　age1</span><br></pre></td></tr></table></figure><mark class="hl-label orange">删除</mark> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表（如果表存在再删除）</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span>  IF <span class="keyword">EXISTS</span> teacher1</span><br></pre></td></tr></table></figure><h2 id="MySQL数据管理"><a href="#MySQL数据管理" class="headerlink" title="MySQL数据管理"></a>MySQL数据管理</h2><h3 id="外键（了解）"><a href="#外键（了解）" class="headerlink" title="外键（了解）"></a>外键（了解）</h3><mark class="hl-label orange">方法一、在创建表的时候，增加约束（麻烦，比较复杂</mark> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>`grade`(</span><br><span class="line"> `gradeid` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;年级id&#x27;</span>,</span><br><span class="line"> `gradename` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年纪名称&#x27;</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY(`gradeid`)</span><br><span class="line"> )ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 学生表的gradeid字段要去引用年纪表的grandeid</span></span><br><span class="line"><span class="comment">-- 定义外键key</span></span><br><span class="line"><span class="comment">-- 给这个外键添加约束（执行引用） references  引用</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `student`(</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;匿名&#x27;</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  `pwd` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;123456&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `sex` <span class="type">VARCHAR</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;女&#x27;</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">  `birthday` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;出生日期&#x27;</span>,</span><br><span class="line">  `gradeid` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学生的年纪&#x27;</span>,</span><br><span class="line">  `address` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;家庭住址&#x27;</span>,</span><br><span class="line">  `emial` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(`id`),</span><br><span class="line">  KEY `FK_gradeid`(`gradeid`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `FK_gradeid` <span class="keyword">FOREIGN</span> KEY (`gradeid`) <span class="keyword">REFERENCES</span> `grade`(`gradeid`)</span><br><span class="line">  )ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8; </span><br></pre></td></tr></table></figure><mark class="hl-label 在创建">方式二</mark> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ALTER TABLE　表 ADD　CONSTRAINT　约束名　FOREIGN KEY(作为外键的列) REFERENCES 那个表（哪个字段)</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> `FK_gradeid` FOREING　KEY(`gradeid`) <span class="keyword">REFERENCES</span> `grade`(`gradeid`);</span><br></pre></td></tr></table></figure><h3 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h3><p><strong>数据库意义</strong> ：数据存储，数据管理</p><p>DML语言：数据操作语言</p><ul><li>Insert</li><li>update</li><li>delete</li></ul><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><blockquote><p>insert</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入语句（添加）</span></span><br><span class="line"><span class="comment">-- insert into 表名([字段名1,字段2,字段3])values(&#x27;值1&#x27;),(&#x27;值2&#x27;),(&#x27;值3&#x27;......)</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `grade`(`gradename`) <span class="keyword">VALUES</span>(<span class="string">&#x27;大四&#x27;</span>)</span><br><span class="line"></span><br><span class="line">由于主键自增我们可以省略（如果不写表的字段，它就会一一匹配）</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `grade` <span class="keyword">VALUES</span>(<span class="string">&#x27;大四&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一般写入插入语句，我们必须要将数据和字段一一对应</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多个字段</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `grade`(`gradename`)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;大二&#x27;</span>),(<span class="string">&#x27;大一&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student`(`name`) <span class="keyword">VALUES</span>(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student`(`naem`.`pwd`,`sex`) <span class="keyword">VALUES</span>(<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;aaaaa&#x27;</span>,<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student`(`name`,`pwd`,`sex`) <span class="keyword">VALUES</span>(<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;aaaaa&#x27;</span>,<span class="string">&#x27;男&#x27;</span>),(<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="string">&#x27;男&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><blockquote><p>update   修改谁   （条件)          set原来的值&#x3D;新值</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改学员名字，带了简介</span></span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;小明&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不指定条件的情况下，会改动所有的表;</span></span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;孙红雷&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改多个属性，逗号隔开</span></span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;狂神&#x27;</span>,`email`<span class="operator">=</span><span class="string">&#x27;1759546023@xx.com&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 语法</span></span><br><span class="line"><span class="comment">-- UPDATE 表名 set colnum_name=value,[colnum_name=vaues.....] WHERE [条件]</span></span><br></pre></td></tr></table></figure><mark class="hl-label blue">条件</mark> ：where子句  运算符  id等于某个值，大于某个值，在某个区间内修改......<p>操作符会返回布尔值</p><table><thead><tr><th align="center">操作符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt;或者!&#x3D;</td><td align="center">不等于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于等于</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于等于</td></tr><tr><td align="center">BETWEEN…AND……</td><td align="center">耨个范围</td></tr><tr><td align="center">AND</td><td align="center">我和你&amp;&amp;</td></tr><tr><td align="center">OR</td><td align="center">我或你 ||</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--通过多个条件定位数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> `student` <span class="keyword">SET</span> <span class="string">&#x27;name&#x27;</span><span class="operator">=</span><span class="string">&#x27;长江7号&#x27;</span> <span class="keyword">WHERE</span> <span class="string">&#x27;name&#x27;</span><span class="operator">=</span><span class="string">&#x27;狂神44&#x27;</span> <span class="keyword">AND</span> sex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span></span><br></pre></td></tr></table></figure><p>语法：update 表名  set colnum_name &#x3D; value,[colnum_name&#x3D;value…….]  where [条件]</p><p>注意：</p><ul><li>colnum_name 是数据库的列，尽量带上&#96;&#96;</li><li>条件，筛选的条件</li><li>value，是一个具体的值，也可以是一个变量</li><li>多个设置的属性之间，使用英文逗号隔开</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> `student` <span class="keyword">set</span> `birthday`<span class="operator">=</span>cruent_time <span class="keyword">where</span> `name`<span class="operator">=</span><span class="string">&#x27;长江七号&#x27;</span> <span class="keyword">and</span> sex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>delete命令</p></blockquote><p>语法： delete from 表名 [where 条件]</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除 数据(避免这样写，会全部删除)</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `student`</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除指定数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `student` <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>truncate命令</p></blockquote><p>作用：完全清空一个数据库表，表的结构和索引约束不会变</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 清空student表</span></span><br><span class="line"><span class="keyword">truncate</span> `student`</span><br></pre></td></tr></table></figure><blockquote><p>delete 与truncate区别</p></blockquote><ul><li>相同点：都能删除数据，都不会删除表的结构</li><li>不同：<ul><li>truncate  重新设置  自增列   计数器会归零</li><li>truncate  不会影响事务</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 测试delete 和truncate　区别</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `test`(</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">    <span class="string">&#x27;coll&#x27;</span> varcahr(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(`id`)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `test`(`coll`) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>),(<span class="string">&#x27;2&#x27;</span>),(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">into</span> `test`(`coll`) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>),(<span class="string">&#x27;2&#x27;</span>),(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `test`  <span class="comment">-- 不会影响自增</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> `test`  <span class="comment">-- 自增会归零</span></span><br></pre></td></tr></table></figure><p>了解：delete删除的问题，重启数据库现象</p><ul><li>innodb 自增列会重1开始（存在内存中的断电即失现象）</li><li>MyISAM   继续从上一个自增量开始（存在文件中，不会丢失）</li></ul><h2 id="DQL查询数据（最重点）"><a href="#DQL查询数据（最重点）" class="headerlink" title="DQL查询数据（最重点）"></a>DQL查询数据（最重点）</h2><p>（Data Query Language: 数据查询语言）</p><ul><li>所有的查询操作都用它</li><li>简单的查询，复杂的查询它都能做</li><li>数据库中最核心的语言，最重要的语句</li><li>使用频率最高的语句</li></ul><h3 id="指定查询字段"><a href="#指定查询字段" class="headerlink" title="指定查询字段"></a>指定查询字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询全部的学生  select 字段 from 表</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询指定字段</span></span><br><span class="line"><span class="keyword">select</span> `studentNo`,`Student` <span class="keyword">from</span> student</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 别名，给结果起一个名字  AS 可以给字段起别名，也可以给表起别名</span></span><br><span class="line"><span class="keyword">select</span> `studentNo` <span class="keyword">as</span> 学号，`StudentName` <span class="keyword">as</span> 学生姓名 <span class="keyword">from</span> studnet <span class="keyword">as</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数  Concat(a,b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;姓名：&#x27;</span>,StudentName) <span class="keyword">as</span> 新名字 <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure><p>语法：select 字段….. from 表</p><blockquote><p>去重 distinct</p></blockquote><p>作用：去除select 查询出来的结果中重复的数据，重复的数据只显示一条</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询一下有哪些同学参加了考试，成绩</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">result</span> <span class="comment">-- 查询全部的考试成绩</span></span><br><span class="line"><span class="keyword">select</span> `Student` <span class="keyword">from</span> <span class="keyword">result</span> <span class="comment">-- 查询有哪些同学参加了考试</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> `StudentNo` <span class="keyword">from</span> <span class="keyword">result</span> <span class="comment">-- 发现重复数据</span></span><br></pre></td></tr></table></figure><blockquote><p>数据库的列（表达式）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> version()  <span class="comment">-- 查询系统版本（函数）</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">100</span><span class="operator">*</span><span class="number">3</span><span class="number">-1</span>  <span class="keyword">as</span> 计算结果  <span class="comment">-- 用来计算 （表达式）</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@auto_increment_increment</span>  <span class="comment">-- 查询自增的步长（变量）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--  学员考试成绩+1分查看</span></span><br><span class="line"><span class="keyword">select</span> `StudentNO`,`StudentResult`<span class="operator">+</span><span class="number">1</span> <span class="keyword">as</span> <span class="string">&#x27;提分后&#x27;</span> <span class="keyword">from</span> <span class="keyword">result</span></span><br></pre></td></tr></table></figure><p>数据库中的表达式：文本值，列，Null，函数，计算表达式，系统变量</p><p>select 表达式 from 表</p><h3 id="where-条件字句"><a href="#where-条件字句" class="headerlink" title="where 条件字句"></a>where 条件字句</h3><p>作用：检索数据中符合条件的值</p><p>搜索的条件由一个或者多个表达式组成！结果</p><blockquote><p>逻辑运算符</p></blockquote><table><thead><tr><th>运算符</th><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>and &amp;&amp;</td><td>a and b    a&amp;&amp;b</td><td>逻辑与，两个都为真，结果为真</td></tr><tr><td>or ||</td><td>a or b    a||b</td><td>逻辑或，其中一个为真，则结果为真</td></tr><tr><td>Not  !</td><td>not  a    !a</td><td>逻辑非，真为假，假为真</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `StudentNo`,`StudentResult` <span class="keyword">from</span> <span class="keyword">result</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询考试</span></span><br><span class="line"><span class="keyword">select</span> `StudentNo`，`StudentResult` <span class="keyword">from</span> <span class="keyword">result</span> <span class="keyword">where</span> </span><br><span class="line">`StudentResult`<span class="operator">&gt;=</span><span class="number">95</span> <span class="keyword">and</span> `StudentResult`<span class="operator">&lt;=</span><span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- and   &amp;&amp;</span></span><br><span class="line"><span class="keyword">select</span> `StudentNo`,`StudentResult` <span class="keyword">from</span> <span class="keyword">result</span> <span class="keyword">where</span></span><br><span class="line">`StudentResult`<span class="operator">&gt;=</span><span class="number">95</span> <span class="operator">&amp;&amp;</span> `StudentResult`<span class="operator">&lt;=</span><span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模糊查询（区间）</span></span><br><span class="line"><span class="keyword">select</span> `StudentNo`,`StudentResult` <span class="keyword">from</span> <span class="keyword">result</span> <span class="keyword">where</span></span><br><span class="line">`StudentResult` <span class="keyword">between</span> <span class="number">95</span> <span class="keyword">and</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 除了10000号学生以外的同学成绩</span></span><br><span class="line"><span class="keyword">select</span> `StudentNo`,`StudentResult` <span class="keyword">from</span> <span class="keyword">result</span> <span class="keyword">where</span></span><br><span class="line">`StudentResult`<span class="operator">!=</span><span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- not</span></span><br><span class="line"><span class="keyword">select</span> `StudentNo`,`StudentResult` <span class="keyword">from</span> <span class="keyword">result</span> <span class="keyword">where</span>  <span class="keyword">not</span> `StudentResult`<span class="operator">=</span><span class="number">1000</span></span><br></pre></td></tr></table></figure><blockquote><p>模糊查询：比较运算符</p></blockquote><table><thead><tr><th>运算符</th><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>is null</td><td>a  is null</td><td>如果操作符为null，结果为真</td></tr><tr><td>is not null</td><td>a is not null</td><td>如果操作符不为null，结果为真</td></tr><tr><td>between</td><td>a between b and c</td><td>若a在b和c之间，则结果为真</td></tr><tr><td>like</td><td>a like b</td><td>SQL匹配。如果a匹配b，则结果为真</td></tr><tr><td>in</td><td>a in (a1,a2,a3……)</td><td>假设a在a1，或者a2…….其中的某一个值中，结果为真</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询姓刘的同学</span></span><br><span class="line"><span class="comment">-- like结合%（代表0到任意字符）  </span></span><br><span class="line"><span class="keyword">select</span> `StudentNo`,`StudentName` <span class="keyword">from</span> `studnet` <span class="keyword">where</span> </span><br><span class="line">`StudentName` <span class="keyword">like</span> <span class="string">&#x27;刘%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓刘的同学，名字后面只有一个字的，_（一个字符）</span></span><br><span class="line"><span class="keyword">select</span> `StudentNo`,`StudentName` <span class="keyword">from</span> `studnet` <span class="keyword">where</span> </span><br><span class="line">`StudentName` <span class="keyword">like</span> <span class="string">&#x27;刘_&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓刘的同学，名字后面只有两个个字的，_（一个字符）</span></span><br><span class="line"><span class="keyword">select</span> `StudentNo`,`StudentName` <span class="keyword">from</span> `studnet` <span class="keyword">where</span> </span><br><span class="line">`StudentName` <span class="keyword">like</span> <span class="string">&#x27;刘__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询名字中间有嘉字的同学</span></span><br><span class="line"><span class="keyword">select</span> `StudentNo`,`StudentName` <span class="keyword">from</span> `studnet` <span class="keyword">where</span> </span><br><span class="line">`StudentName` <span class="keyword">like</span> <span class="string">&#x27;%嘉%&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="keyword">in</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line"><span class="comment">-- 查询100,101,102号的学生</span></span><br><span class="line"><span class="keyword">select</span> `StudentNo`,`StudentName` <span class="keyword">from</span> `studnet` <span class="keyword">where</span> </span><br><span class="line">`StudentNo` <span class="keyword">in</span> (<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="keyword">null</span> <span class="keyword">not</span> <span class="keyword">null</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line"><span class="comment">-- 查询地址为空的学生</span></span><br><span class="line"><span class="keyword">select</span> `StudentNo`,`StudentName` <span class="keyword">from</span> `studnet` <span class="keyword">where</span> </span><br><span class="line">`address` <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h3 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h3><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>inner join</td><td>如果表中至少有一个匹配，就返回行</td></tr><tr><td>left join</td><td>即使右表中没有匹配，也会从左表中返回所有的值</td></tr><tr><td>right join</td><td>会从右表中返回所有的值，即使左表中没有匹配</td></tr></tbody></table><blockquote><p>自连接</p></blockquote><p>自己的表和自己的表连接，核心是一张表拆成两张一样的表即可</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础-泛型</title>
      <link href="/2023/06/16/Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/06/16/Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是泛型？"><a href="#1-什么是泛型？" class="headerlink" title="1.什么是泛型？"></a>1.什么是泛型？</h2><pre><code>Java推出泛型之前，程序员可以构建一个元素类型为Object的集合，虽然可以储存任意的数据类型对象，但是需要程序员知道存储，每个元素的数据类型，否则很容易引发**ClassCastException**异常。</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven基础学习笔记回顾</title>
      <link href="/2023/06/09/maven%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9E%E9%A1%BE/"/>
      <url>/2023/06/09/maven%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么学习Maven"><a href="#为什么学习Maven" class="headerlink" title="为什么学习Maven"></a>为什么学习Maven</h2><p>现在有这样两个场景：</p><pre><code>场景一：我们项目需要第三方库（依赖），如Druid连接池、MySQL数据库驱动和jackson等。那么我们可以将需要的依赖项的信息写到Mave工程的配置文件，Maven软件就会自动下载并复制这些依赖项到项目中，也会自动下载依赖需要的依赖！确保依赖版本正确无冲突和依赖完整。场景二：项目开发完成后，想要将项目打包成war文件，并部署到服务器中运行，使用Maven软件，我们可以通过一行构建命令（mvn package）快速项目构建和打包！节省大量时间！</code></pre><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><pre><code>我们在javaWeb阶段也用到jar包，不过基本上主要还是用原生api开发，没有经过框架封装整合。随着我们使用越来越多的框架，项目中的jar包也越来越多。其次就是jar包的来源不明和下载麻烦，jar包所属的技术的网站，网站通常是英文界面，网站的结构又不尽相同，甚至找到下载链接还发现需要通过特殊的工具下载，第三方网站提供下载。问题是不规范，在使用过程中会出现各种问题。你不能确保jar包的名称、jar包的版本以及jar包内的具体细节是否符合。而使用maven可以管理项目的依赖，包括自动下载所需的依赖库，自动下载依赖的依赖保证版本没有冲突、依赖版本管理。通过Maven，我们可以方便地维护项目所依赖的外部库，而我们仅仅需要编写配置即可。</code></pre><h3 id="构建管理"><a href="#构建管理" class="headerlink" title="构建管理"></a>构建管理</h3><pre><code>一个主要的原因就是脱离了IDE环境任需要构建，在部署到远程端时，不可能在远程端也下载一个IDE；其次互联网的更新非常平凡，经常有新功能要去发布。常见的部署过程如下；</code></pre><p><img src="https://lskypro.codeoneday.top/i/2023/08/17/64ddd31b96901.png" alt="Maven.png"></p><h2 id="什么是Maven"><a href="#什么是Maven" class="headerlink" title="什么是Maven"></a>什么是Maven</h2><pre><code>Maven一款Java项目构建管理、依赖管理的工具（软件），使用Maven可以自动化构建、测试打包和发布项目。</code></pre><h3 id="什么是构建"><a href="#什么是构建" class="headerlink" title="什么是构建"></a>什么是构建</h3><p>构建指的是在java项目开发中使用原材料生产产品的过程。</p><ul><li><p>原材料</p><ul><li>java源代码</li><li>基于HTML的Thymeleaf文件</li><li>图片</li><li>配置文件</li><li>……</li></ul></li><li><p>产品</p><ul><li>一个可以在服务器上运行的项目</li></ul></li></ul><p>构建过程包含的主要的环节：</p><ul><li>删除上一次构建的结果，为下一次构建做好准备</li><li>编译：java源程序编译成**.class**字节码文件</li><li>测试：运行提前准备好的测试程序</li><li>报告：针对刚才测试的结果生成一个全面的信息</li><li>打包：<ul><li>Java工具：jar包</li><li>Web工程：war包</li></ul></li><li>安装：把一个Maven工程经过打包操作生成的jar包或War包安装到Maven仓库</li><li>部署：将准备好的jar包或war包部署到服务器上运行。</li></ul><h3 id="什么是依赖"><a href="#什么是依赖" class="headerlink" title="什么是依赖"></a>什么是依赖</h3><p>如果A工程用到了B工程的类、接口、配置文件这样的资源，那么我们就可以说A依赖于B，例如：</p><p>junit-4.12依赖hamcrest-core-1.3</p><p>依赖管理中需要解决的具体问题</p><ul><li>jar包的下载：使用Maven之后，jar包会从规范的远程仓库下载到本地。</li><li>jar包之间的依赖：通过依赖的传递性自动完成。</li><li>jar包之间的冲突：通过对依赖的配置进行调整，让某些jar包不会被导入。</li></ul><h3 id="Maven的工作机制"><a href="#Maven的工作机制" class="headerlink" title="Maven的工作机制"></a>Maven的工作机制</h3><p><img src="https://lskypro.codeoneday.top/i/2023/08/17/64ddd34c9042e.png" alt="Maven的工作机制.png"></p><h2 id="Maven核心程序配置"><a href="#Maven核心程序配置" class="headerlink" title="Maven核心程序配置"></a>Maven核心程序配置</h2><p>首先要下载maven程序，我下载的版本是3.6.3。</p><h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><p>就如我的核心程序压缩包：apache-maven-3.6.3，解压到<strong>非中文</strong>、<strong>没有空格</strong>的目录。例如：</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/17/64ddd39494b63.png" alt="maven压缩包文件.png"></p><p>在解压目录中，我们能看到上图文件夹和文件</p><mark class="hl-label ：">bin</mark> 含有Maven的运行脚本。<mark class="hl-label default">boot：orange</mark> 含有ploxus-classworlds类加载器框架<mark class="hl-label default">conf：red</mark> 含有settings.xml配置文件。<mark class="hl-label default">lib：green</mark> 含有Maven运行时所需要的java的类库。<mark class="hl-label pink">LINCENSE:</mark> 、<mark class="hl-label pink">NOTICE:</mark> 、<mark class="hl-label pink">README.txt:</mark> 则是针对Maven版本、第三方软件等简单介绍<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>​我们需要着重关心则是Maven的核心配置文件：conf&#x2F;settings.xml，我们需要修改的三个配置：a.依赖本地缓存位置（<mark class="hl-label orange">本地仓库</mark> ），b.maven下载镜像，c.maven选用编译项目的jdk版本。</p><ul><li>a.匹配Maven本地仓库</li></ul><p>本地仓库默认值：<strong>用户home目录&#x2F;.m2&#x2F;repository</strong>。 由于本地仓库的默认位置是在用户的home目录下，而home目录往往在C盘，也就是系统盘。将来Maven仓库中jar包越来越多,仓库体积越来越大，可能会拖慢C盘运行速度，影响系统性能。所以建议将Maven的本地仓库放在其他盘符下。配置方式如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">   | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>F:\maven\repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>b.配置阿里云镜像仓库</li></ul><p>Maven下载jar包默认访问境外的中央仓库，而国外网站速度很慢。改成阿里云提供的镜像仓库，访问国内网站<br>，可以让Maven下载jar包的时候速度更快。配置的方式是：将下面mirror标签整体复制到settings.xml文件<br>的mirrors标签的内部。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>c.配置JDK版本</li></ul><p>如果按照默认配置运行，Java工程使用的默认JDK版本是1.5,而我们熟悉和常用的是JDK 1.8版本。修改配置的<br>方式是:将profile标签整个复制到settings.xml文件的profiles标签内。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">profiles</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>前提条件先检查JAVA_HOME环境变量的配置，Maven是一个Java语言开发的程序，它必须基于JDK来运行，需要通过JAVA_HOME来找到jdk的安装位置。可以在命令行输入下列命令验证：(1).java -version、(2).echo %JAVA_HOME%、(3).echo %PATH%</p><p>​然后开始配置Maven的环境变量</p><ul><li>配置MAVEN_HOME</li></ul><p>​新建“MAVEN_HOME”变量，在变量值一栏输入你的maven核心程序包解压的目录。</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/17/64ddd400037d7.png" alt="新建“MAVEN_HOME”变量.png"></p><ul><li>配置Path</li></ul><p>选中“Path”变量，在变量值的最前面或者最后面添加“;MAVEN_HOME%\bin;”</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/17/64ddd450630e4.png" alt="配置Path.png"></p><p>验证：在命令行输入 <mark class="hl-label -v">mvn</mark> </p><h3 id="在idea中配置本地maven"><a href="#在idea中配置本地maven" class="headerlink" title="在idea中配置本地maven"></a>在idea中配置本地maven</h3><mark class="hl-label red">注意：</mark>  idea自带maven配置软件，但是因为没有修改配置，建议换成本地配置好的maven!<p>打开idea配置文件，构建工具配置，依次点击</p><p>file&#x2F;settings&#x2F;build&#x2F;build tool&#x2F;maven</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/26/64e8e4560f2e2.png" alt="image-20230826012638372"></p><h2 id="Maven工程创建"><a href="#Maven工程创建" class="headerlink" title="Maven工程创建"></a>Maven工程创建</h2><h3 id="Maven工程GAVP属性"><a href="#Maven工程GAVP属性" class="headerlink" title="Maven工程GAVP属性"></a>Maven工程GAVP属性</h3><p>​Maven工程相对于之前的工程，多出一组<mark class="hl-label blue">gavp</mark> 属性，<mark class="hl-label orange">gav</mark> 需要我们在创建项目值指定，<mark class="hl-label default">p</mark> 有默认值，后期可以通过配置文件修改。<mark class="hl-label blue">gavp</mark>  是指groupId、artifactId、version、packaing等四个属性的缩写，其中前三个是必要的，而packaging属性为可选项，这四个属性主要为每个项目在maven仓库做一个标识，用来方便maven软件对项目进行管理和互相引用！</p><p><strong>根据坐标的方式创建Maven工程</strong></p><p>a. Maven核心概念：坐标</p><p>①数学中的坐标使用x，y，z三个作为 <strong>向量</strong>  作为空间的坐标系，可以在 空间中的唯一的定位到一个 点。</p><p>②Maven中的坐标：</p><p>   [1]向量说明<br>使用三个<strong>向量</strong> 在 <strong>Maven的仓库</strong> 中唯一的定位一个 <strong>jar</strong> 包</p><ul><li><strong>groupId</strong> ：公司或组织的id</li><li><strong>artifactId</strong> ：一个项目或者是项目中的一个模块的id</li><li><strong>version</strong> ：版本号</li></ul><p>b. 三个向量取值方式</p><ul><li><p>groupId：公司或组织域名的倒序，通常也会加上项目名称</p><ul><li>例如：com.aliyun.maven</li></ul></li><li><p>artifactId：模块的名称，将来作为Maven工程的工程名</p></li><li><p>version：模块的版本号，根据自己的需求设定，版本格式推荐：  主版本号.此版本号.修订号</p><ul><li>例如：SNAPSHOT表示快照版本</li><li>例如：RELEASE表示正式版本</li><li>主版本号：做了不兼容的API修改，或者增加了能改变产品方向的新功能</li><li>次版本号：做了向下兼容的功能性新增（新增类、接口等）</li><li>修订号：修复bug，没有修改方法签名的功能加强，保持API兼容性</li></ul></li></ul><p>eg：</p><ul><li>groupId：com.atguigu.maven</li><li>artifactId：pro01-atguigu-maven</li><li>version：1.0-SNAPSHOT  ||      初始——&gt; 1.0.0       修改bug——&gt;1.0.1        功能调整——&gt;1.1.1</li></ul><p><strong>坐标和仓库中jar包的存储路径之间的对应关系</strong></p><p>坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据坐标在本地仓库找到对应的jar包</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Maven本地仓库根目录\javaX\servlet\servlet-api\2.5\servlet-api-2.5.jar</span><br></pre></td></tr></table></figure><h3 id="命令行创建Maven-JavaSE工程"><a href="#命令行创建Maven-JavaSE工程" class="headerlink" title="命令行创建Maven JavaSE工程"></a>命令行创建Maven JavaSE工程</h3><p><strong>创建工作区间</strong></p><p>例如：我们现在的工作区间目录是：F:\maven-space\mave-programe01</p><p>在工作区间目录打开命令行或在命令行下切换至工作区间目录</p><p>使用命令生成Maven工程</p><p>运行<mark class="hl-label archetype:generate">mvn</mark> 命令，其中 <code>mvn</code>是<strong>主命令</strong> ，<code>archetype:generate</code>是 <strong>子命令</strong>，在其中 <code>archetype</code>是<strong>插件</strong>，而 <code>generate</code>是<strong>目标</strong>。在运行过程中命令行显示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Choose a number or apply filter(format:[groupId:]artifactId,case sensitive contains):7:</span><br><span class="line">//直接回车，使用默认值</span><br><span class="line">Define value for property &#x27;groupId&#x27;://输入公司或组织域名+项目名称 例如：com.atguigu.maven</span><br><span class="line">Define value for property &#x27;artifactId&#x27;://输入模块名称  例如：pro01-maven-java</span><br><span class="line">Define value for property &#x27;version&#x27; 1.0-SNAPSHOT:: //直接回车，使用默认值</span><br><span class="line">Define value for property &#x27;package&#x27; com.atguigu.maven:: //直接回车，使用默认值</span><br><span class="line">Confirm properties configuration:...//这里会根据你前面输入的内容生成信息要你确认，直接回车，表示确认。如果前面有输入错误，想要重新输入，则输入N再回车。</span><br></pre></td></tr></table></figure><p>结果示意图：</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/17/64ddd49c66512.png" alt="生成Maven工程.png"></p><p><strong>调整junit版本</strong></p><p>Maven默认生成的工程，是对junit依赖比较低的3.8.1版本，我们可以改成较合适的4.12版本，自动生成的App.java和AppTest.java可以删除。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--依赖信息配置--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- dependencies复数标签：里面包含dependency单数标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- depenency单数标签：配置一个具体的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 通过坐标来依赖其他jar包--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="idea创建Maven-JavaSE工程"><a href="#idea创建Maven-JavaSE工程" class="headerlink" title="idea创建Maven  JavaSE工程"></a>idea创建Maven  JavaSE工程</h3><p>这里可以采用创建空项目，使用maven构建。而下面的<code>Maven Archtype</code>和上面通过命令行输入命令行的方式差不多。</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/26/64e8ef3c258b9.png" alt="image-20230826021315630"></p><h3 id="idea创建Maven-JavaEE工程"><a href="#idea创建Maven-JavaEE工程" class="headerlink" title="idea创建Maven JavaEE工程"></a>idea创建Maven JavaEE工程</h3><p>创建JavaEE工程，可以在前面的创建的工程基础上手动创建，只需要做到以下步骤：</p><p>a.  手动添加web项目结构文件</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/26/64e9075500cb7.png" alt="image-20230826035558011"></p><p>b. 修改pom.xml文件打包方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以通过通过插件安装的方式</p><p>a.  安装插件<mark class="hl-label orange">JBLJavaToWeb</mark> </p><p><img src="https://lskypro.codeoneday.top/i/2023/08/26/64e9830b88698.png" alt="image-20230826124348613"></p><p>b.  在Maven工程上右键选中——<code>JBLJavaWeb</code></p><p><img src="https://lskypro.codeoneday.top/i/2023/08/26/64e984b4c6096.png" alt="image-20230826125100923"></p><h3 id="Maven工程项目结构说明"><a href="#Maven工程项目结构说明" class="headerlink" title="Maven工程项目结构说明"></a>Maven工程项目结构说明</h3><p>Maven是一个强大的构建工具，它提供一种标准化的项目结构，帮助开发者跟容易管理项目的依赖、构架、测试和发布等任务。以下是Maven Web程序的文件结构以及每个文件的作用</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/26/64e9913c748dc.png" alt="image-20230826134421166"></p><p><img src="https://lskypro.codeoneday.top/i/2023/08/17/64ddd4d1933bf.png" alt="各个目录的作用.png"></p><h2 id="依赖管理和构建管理"><a href="#依赖管理和构建管理" class="headerlink" title="依赖管理和构建管理"></a>依赖管理和构建管理</h2><h3 id="依赖管理和配置"><a href="#依赖管理和配置" class="headerlink" title="依赖管理和配置"></a>依赖管理和配置</h3><p>​Maven依赖管理是Maven软件中最重要的功能之一。Maven的依赖管理能够帮助开发人员自动解决软件包依赖问题，使开发人员能够轻松地将其他开发人员的模块或第三方框架集成到自己的应用或模块中，避免出现版本冲突和依赖缺失等问题。</p><p>​我们通过定义POM文件，Maven能够自动解析项目的依赖关系，通过Maven仓库自动下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。</p><p><strong>pom.xml的含义</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>porject是根标签，表示对当前工程进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br></pre></td></tr></table></figure><p>modelVersion从Maven 2开始就是4.0.0</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些就是前面我们介绍的坐标信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><mark class="hl-label green">packaging</mark> 标签：**打包方式**<p> 1.取值<strong>jar</strong>：生成jar包，说明这是一个<strong>Java</strong>工程。</p><p> 2.取值<strong>war</strong>：生成war包，说明这是一个Web工程。</p><p>3.取值<strong>pom</strong>，说明这个工程是用来管理其他工程的工程。</p><p><strong>第三方依赖信息声明</strong></p><p>dependencies   -  项目依赖信息的集合</p><p>​dependency   -  每个依赖项</p><p>​[gav]     - 依赖的信息，就是其他Maven的工程 [jar]   </p><p>如何知道第三方依赖信息？</p><ol><li>maven提供的查询官网  <a href="https://mavenrepository.com/">https://mavenrepository.com</a> </li><li>maven插件 maven-search</li></ol><h3 id="依赖传递和冲突"><a href="#依赖传递和冲突" class="headerlink" title="依赖传递和冲突"></a>依赖传递和冲突</h3><p><code>依赖传递</code>指定的是当一个模块或库依赖于另外一个模块或库B，而B又依赖于模块或库C，那么A会依赖于C。这种依赖传递结构可以形成一个依赖树。当我们引入一个库或框架时，构建工具（如Maven、Gradle）会自动解析和加载其所有的直接和间接依赖，确保这些依赖都可以用。</p><mark class="hl-label default">依赖传递的作用是：blue</mark> <ol><li><p>减少重复依赖：当多个项目依赖同一个库时，Maven可以自动下载并且只用下载该库，这样可以减少项目的构建时间和磁盘空间。</p></li><li><p>自动管理依赖：Maven可以自动管理依赖项，使用依赖传递，简化了依赖项的管理，使项目构建更加可靠和一致。</p></li><li><p>确保依赖版本的正确性：通过依赖传递的依赖，之间都不会存在版本兼容性问题，确实依赖依赖版本的正确性。</p></li></ol><p><code>依赖冲突</code>：发现已经存在依赖（重复依赖）会终止依赖传递！避免循环依赖和重复依赖的问题！</p><p>依赖冲突发生场景：重复依赖！</p><mark class="hl-label orange">依赖冲突的解决原则：</mark> <p>第一步原则：谁短谁优先！引用的路径长度</p><p>第二原则：谁上谁优先！dependencies声明的先后顺序</p><h3 id="依赖导入失败的场景和解决方案"><a href="#依赖导入失败的场景和解决方案" class="headerlink" title="依赖导入失败的场景和解决方案"></a>依赖导入失败的场景和解决方案</h3><p>​在使用Maven构建项目的时，可能会发生依赖项下载错误的情况，主要原因有以下几种情况：</p><p>1、下载依赖时出现网络故障或仓库服务器宕机等原因，导致无法连接到Maven仓库，从而无法下载依赖。</p><p>2、依赖项的版本号和配置文件中的版本号错误，或者依赖项没有正确定义，导致Maven下载的依赖项与实际需要的不一致，从而引发错误。</p><p>3、本地Maven仓库或缓存被污染或损坏，导致Maven无法正确地使用现有的依赖项，并且也无法重新下载！</p><mark class="hl-label default">解决方案：</mark> <p>1、检查网络连接和Maven仓库服务器状态。</p><p>2、确保依赖项的版本号与项目对应的版本号匹配，并检查POM文件中的依赖项是否正确。</p><p>3、清除本地Maven仓库缓存（lastUpdated文件），因为只要存在lastupdated缓存文件，刷新也不会重新下载。本地仓库中，根据依赖的gav属性依次向下查找文件夹，最终删除内部的文件，刷新重新下载即可！</p><h3 id="扩展构建管理"><a href="#扩展构建管理" class="headerlink" title="扩展构建管理"></a>扩展构建管理</h3><p>命令方式构建：</p><p>语法：<mark class="hl-label 构建命令">mvn</mark> </p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>mvn clean</td><td>清理编译后或打包后的项目结构，删除target文件夹</td></tr><tr><td>mvn compile</td><td>变异项目，生成target文件</td></tr><tr><td>mvn test</td><td>执行测试源码</td></tr><tr><td>mvn site</td><td>生成一个项目依赖信息的展示页面</td></tr><tr><td>mvn package</td><td>打包项目，生成war&#x2F;jar文件</td></tr><tr><td>mvn install</td><td>打包后上传到maven本地仓库（本地部署）</td></tr><tr><td>mvn deploy</td><td>只打包，上传到maven私服仓库（私服</td></tr></tbody></table><p><strong>构建命令周期</strong></p><p>构建生命周期可以理解是一组固定构建命令的有序集合，触发周期后的命令，会自动触发周期前的命令！也是简化构建的思路！</p><ul><li><p>清理周期：主要对项目编译生成文件进行清理</p><p>包含命令：clean</p></li><li><p>默认周期：定义了真正构件时所需于执行的所有步骤，它是生命周期中最核心的部分</p><p>包含命令：complie-test-package-install&#x2F;deploy</p></li><li><p>报告周期</p><p>包含命令：site</p><p>打包：mvn clean package 本地仓库：mvn clean install</p></li></ul><h2 id="Maven继承和聚合特性"><a href="#Maven继承和聚合特性" class="headerlink" title="Maven继承和聚合特性"></a>Maven继承和聚合特性</h2><h3 id="Maven工程继承关系"><a href="#Maven工程继承关系" class="headerlink" title="Maven工程继承关系"></a>Maven工程继承关系</h3><p>Maven继承是指Maven的项目中，让一个项目从另一个项目中继承配置信息的机制。继承可以让我们在多个项目中共享同一配置信息，简化项目的管理和维护工作。</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/26/64e9fd5c32bab.png" alt="image-20230826212541215"></p><p>2.继承作用：在父工程中统一管理项目中的依赖信息，进行统一的版本管理。</p><p>3.继承语法</p><ul><li><p>父工程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupiId</span>&gt;</span>com.exmaple.maven<span class="tag">&lt;/<span class="name">groudiId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当前工程为工程，它要去管理子工程，所以打包方式必须是pom --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaing</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaing</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>子工程</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 父工程的坐标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子工程的坐标 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果子坐标中的groupId和version与父工程一致，那么可以省略&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;groupId&gt;com.example.maven&lt;/groupId&gt; --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm-maven-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;</span></span><br></pre></td></tr></table></figure><p>4.父工程依赖统一管理</p><ul><li>父工程声明版本</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用dependencyMangement标签配置对依赖的管理 ——&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.exmample<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifacId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifacId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Maven-工程聚合关系"><a href="#Maven-工程聚合关系" class="headerlink" title="Maven 工程聚合关系"></a>Maven 工程聚合关系</h3><ol><li><p>聚合概念</p><p>Maven聚合是指多个项目组织到一个父级项目中，通过触发父工程的建构，统一按顺序触发子工程构建的工程！</p></li><li><p>聚合作用</p><p>a. 统一管理子项目构建：通过聚合，可以将多个子项目组织在一起，方便管理和维护。</p><p>b.优化构建顺序：通过聚合，可以对多个项目进行顺序控制，避免出现构建依赖混乱导致构建失败的情况。</p></li><li><p>聚合语法</p><p>父项目中包含的子项目列表。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent-porject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packing</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packing</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>child-project1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>child-project2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github+picgo搭建markdown图床</title>
      <link href="/2023/02/28/github-picgo%E6%90%AD%E5%BB%BAmarkdown%E5%9B%BE%E5%BA%8A/"/>
      <url>/2023/02/28/github-picgo%E6%90%AD%E5%BB%BAmarkdown%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="github-picgo-搭建-markdown-图床"><a href="#github-picgo-搭建-markdown-图床" class="headerlink" title="github+picgo 搭建 markdown 图床"></a>github+picgo 搭建 markdown 图床</h2><h3 id="GitHub配置"><a href="#GitHub配置" class="headerlink" title="GitHub配置"></a>GitHub配置</h3><h4 id="建立一个仓库，必须为public"><a href="#建立一个仓库，必须为public" class="headerlink" title="建立一个仓库，必须为public"></a>建立一个仓库，必须为public<img src="https://lskypro.codeoneday.top/i/2023/08/17/64ddad6a367c3.png" alt="github图床仓库设置.png"></h4><h4 id="获取tokens"><a href="#获取tokens" class="headerlink" title="获取tokens"></a>获取tokens</h4><ul><li><p>进入个人设置页面，依次选择<code>developer settings</code> –&gt; <code>Personal access tokens</code>，然后点击<code>Generate new token</code>，来生成新的<strong>tokens</strong>，<strong>tokens</strong>也就是令牌，在图床上传时验证身份用的。</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/17/64ddadb545df7.png" alt="获取token.png"></p></li><li><p>添加描述，把<strong>repo</strong>选上。</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/17/64ddae020c412.png" alt="Token的具体设置.png"></p></li><li><p>保存生成的字符串</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/17/64ddae5bc9408.png" alt="Token生成的字符串.png"></p></li></ul><h3 id="picgo配置"><a href="#picgo配置" class="headerlink" title="picgo配置"></a>picgo配置</h3><h4 id="pico-插件"><a href="#pico-插件" class="headerlink" title="pico 插件"></a>pico 插件</h4><ul><li><p>首先，要借助<strong>vscode</strong>，在 <strong>vscode</strong> 中点击扩展(快捷鍵<code>crtrl</code>+<code>shift</code>+<code>X</code>)，搜索picgo安装下载</p></li><li><p>在设置中配置<strong>picgo</strong>，在vscode设置界面搜索picgo，具体的配置如下：</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/17/64ddaf0f7d26d.png" alt="vscode中picgo插件配置-github.png"></p><ul><li><p><strong>Current</strong>设置<strong>GitHub</strong>，</p></li><li><p><strong>Branch</strong>就是仓库分支，默认设置<strong>main</strong>，</p></li><li><p><strong>custom url</strong>就是我们仓库的分支，这里有两种方式可以使用：</p><ol><li><p>原生方式，弊端就是国内的访问速度比较慢</p><p>xxxxxxxxxx git push -u origin main #第一次提交加上-u参数，后续不需要git</p><p>eg：<a href="https://raw.githubusercontent.com/LKFhnust18/picgo/main">https://raw.githubusercontent.com/LKFhnust18/picgo/main</a></p></li><li><p>xxxxxxxxxx git pull origin &lt;分支名&gt; #拉取远程分支的代码，如果有冲突就先解决冲突再提交代码git</p><p>xxxxxxxxxx git pull origin &lt;分支名&gt; #拉取远程分支的代码，如果有冲突就先解决冲突再提交代码git</p><p>eg：<a href="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main">https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main</a></p></li></ol></li><li><p><strong>path</strong>就是我们的图片存储在仓库中的路径，eg：img&#x2F;</p></li><li><p><strong>repo</strong>就是我们的仓库</p></li><li><p><strong>Token</strong>，即GitHub中获取的Tokens</p></li></ul></li><li><p>上传方式：进入vscode，在你想要复制的地方使用快捷键【<code>ctrl+alt+U</code>】从剪贴板上粘贴图片，[<code>ctrl</code>+<code>alt</code>+<code>U</code>]打开资源管理器，选择图片上传。</p></li></ul><h4 id="picgo-的PC端"><a href="#picgo-的PC端" class="headerlink" title="picgo 的PC端"></a>picgo 的PC端</h4><p>这个可以结合<strong>Typora</strong>使用，下面是picgo的具体配置图</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/17/64ddaf9f23e4c.png" alt="PicGo的PC端设置-github.png"></p><p>在typora中的配置图</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/17/64ddd22032d9b.png" alt="typora设置-picgo.png"></p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu安装node.js和npm</title>
      <link href="/2023/02/28/Ubuntu%E5%AE%89%E8%A3%85node-js%E5%92%8Cnpm/"/>
      <url>/2023/02/28/Ubuntu%E5%AE%89%E8%A3%85node-js%E5%92%8Cnpm/</url>
      
        <content type="html"><![CDATA[<h2 id="Ubuntu安装node-js和npm"><a href="#Ubuntu安装node-js和npm" class="headerlink" title="Ubuntu安装node.js和npm"></a>Ubuntu安装node.js和npm</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Node.js是一个跨平台的JavaScript运行环境，它构建在 为了服务器端运行JavaScript代码而设计的Chrome JavaScript上，它通常被用来构建后端应用，但它是非常流行的全栈和前端解决方案。npm是node.js的默认包管理工具，也是世界上最大的软件仓库。下面记录Ubuntu安装node.js和npm三种不同的方式。</p><h3 id="从Ubuntu软件源安装node-js和npm"><a href="#从Ubuntu软件源安装node-js和npm" class="headerlink" title="从Ubuntu软件源安装node.js和npm"></a>从Ubuntu软件源安装node.js和npm</h3><ul><li>更新软件包索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><ul><li>安装node.js和npm</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install node.js npm   #这一条命令会自动安装一系列包，包括编译和安装npm的本地扩展</span><br></pre></td></tr></table></figure><ul><li>验证是否安装成功</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.js -version#查看node.js的版本</span><br><span class="line">npm -version #查看npm的版本</span><br></pre></td></tr></table></figure><h3 id="从NodeSource中安装Node-js和npm"><a href="#从NodeSource中安装Node-js和npm" class="headerlink" title="从NodeSource中安装Node.js和npm"></a>从NodeSource中安装Node.js和npm</h3><p>NodeSource是一家公司，提供企业级的Node支持。它维护了一个APT软件源，其中包含了很多node.js版本。如果你的应用需要制定版本的Node.js版本，就可以使用这个软件源。比如这里我们安装14.x的node.js版本：</p><ul><li>以sudo用户的身份运行下面的命令，运行安装NodeSource的安装脚本。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_14.X | sudo -E bash -</span><br></pre></td></tr></table></figure><p>这个脚本会添加NodeSource的签名key到你的系统，创建一个apt源文件，安装必备的软件包，并刷新apt缓存。</p><ul><li>NodeSource源启动成功后，安装node.js和npm</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install node.js#这个nide.js安装包同时包含node.js和npm</span><br></pre></td></tr></table></figure><ul><li>验证Node.js和npm是否正常安装，打印它们的版本号：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node --version</span><br><span class="line">npm --version</span><br></pre></td></tr></table></figure><p>如果想从npm编译本地扩展，你需要安装开发工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure><h3 id="从NVM安装node-js和npm"><a href="#从NVM安装node-js和npm" class="headerlink" title="从NVM安装node.js和npm"></a>从NVM安装node.js和npm</h3><p>NVM（Node Version Manger）是一个Bash脚本，它允许你为每一个用户管理多个Node.js版本。使用NVM，你可以随时安装或者卸载任何想要的使用或者测试的Node.js版本</p><ul><li>浏览nvm页面，并且拷贝下面的curl或者wget命令去下载和nvm版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash</span><br></pre></td></tr></table></figure><p>不要使用sudo运行，因为root用户会启用nvm</p><ul><li>验证nvm是否被正确安装，输入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm --version</span><br></pre></td></tr></table></figure><ul><li>获取node.js版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm list-remote</span><br></pre></td></tr></table></figure><ul><li>安装node</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm install node#安装最新版的node</span><br><span class="line">nvm install --lts#安装最新的长期版本node</span><br><span class="line">nvm install 10.9.0#安装版本10.9.0</span><br></pre></td></tr></table></figure><ul><li>输出已安装的node版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls</span><br></pre></td></tr></table></figure><ul><li>修改当前使用的版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use 12.16.3</span><br></pre></td></tr></table></figure><ul><li>修改默认的node.js版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm alias default 12.16.3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java的常用类</title>
      <link href="/2023/02/14/java%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
      <url>/2023/02/14/java%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="包装类的分类"><a href="#包装类的分类" class="headerlink" title="包装类的分类"></a>包装类的分类</h3><p>1.针对八种基本数据类型相应的引用数据类型——包装类（Wrapper）<br>2.有了类的特点，就可以调用类中的方法</p><table><thead><tr><th align="center">基本类型</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">Boolean</td></tr><tr><td align="center">char</td><td align="center">Character</td></tr><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr></tbody></table><h3 id="包装类和基本数据的转换"><a href="#包装类和基本数据的转换" class="headerlink" title="包装类和基本数据的转换"></a>包装类和基本数据的转换</h3><h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><p>（1）JDK前的手动装箱和拆箱方式，装箱：基本类型——&gt;包装类型，反之，拆箱。</p><p>（2）JDK5以后（包含JDK5）的自动装箱和拆箱方式</p><p>（3）自动装箱底层调用的是valueOf方法，比如Integer.valueOf()；</p><p>通过一个Integer实例理解上述内容（其他的包装类类似）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//演示int&lt;--&gt;Integer 的装箱和拆箱</span></span><br><span class="line">       <span class="comment">//JDK5以前是手动装箱和拆箱</span></span><br><span class="line">       <span class="comment">//手动装箱  int-&gt;Integer</span></span><br><span class="line">       <span class="type">int</span> n1=<span class="number">100</span>;</span><br><span class="line">       <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n1);<span class="comment">//手动装箱</span></span><br><span class="line">       Integer integer1=Integer.valueOf(n1);<span class="comment">//或者这种</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//手动拆箱</span></span><br><span class="line">       <span class="comment">//integer-&gt;int</span></span><br><span class="line">       <span class="type">int</span> n2=integer.intValue();</span><br><span class="line">       System.out.println(n2);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//JDK5以后，就可以自动装箱和自动拆箱</span></span><br><span class="line">       <span class="type">int</span> n3=<span class="number">200</span>;</span><br><span class="line">       <span class="comment">//自动装箱 Integer-&gt;int</span></span><br><span class="line">       Integer integer2=n3;   <span class="comment">//底层使用的是 Integer.valueOf(n3)方法</span></span><br><span class="line">    <span class="type">int</span> n4=integer2.intValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里有一个经典问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj1=<span class="literal">true</span>?<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>):<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(obj1);</span><br></pre></td></tr></table></figure><p>这里<strong>obj1</strong> 输出的是<strong>1.0</strong>，这是因为三元运算符是一个整体。</p><h4 id="包装类型和String类型的转换"><a href="#包装类型和String类型的转换" class="headerlink" title="包装类型和String类型的转换"></a>包装类型和String类型的转换</h4><p>这里以Integer和String转换为例，其他类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类(Integer)-&gt;String</span></span><br><span class="line">       Integer i=<span class="number">100</span>;</span><br><span class="line">       <span class="comment">//方式一</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="comment">//方式二</span></span><br><span class="line">       String str2=i.toString();</span><br><span class="line">       <span class="comment">//方式三</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//String-&gt;包装类(Integer)</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">       Integer i2=Integer.parseInt(str4);  <span class="comment">//返回的是int类型，但是使用了自动装箱</span></span><br><span class="line">       <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(str4);</span><br></pre></td></tr></table></figure><p>Character的几个常用方法</p><ul><li>isDigit(‘a’)， 判断是不是数字</li><li>isLetter(‘a’)，判断是不是字母</li><li>isUpperCase(‘a’)，判断是不是大写</li><li>isLowerCase(‘a’)，判断是不是小写</li><li>isWhitespace(‘a’)，判断是不是空格</li><li>toUpperCase(‘a’)，&#x2F;&#x2F;转成大写</li><li>toLowerCase(“A”)，转成小写</li></ul><p>Integer的一个面试题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(i==j);<span class="comment">//F</span></span><br><span class="line"></span><br><span class="line">Integer m=<span class="number">1</span>;</span><br><span class="line">Integer n=<span class="number">1</span>;</span><br><span class="line">System.out.println(m==n);<span class="comment">//T</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(x==y);<span class="comment">//F</span></span><br></pre></td></tr></table></figure><p>之所以会出现上述结果的原因是第一个是new出来的，所以i和j是两个不同的对象。第二个和第三个不同的原因是根据Integer的源码，取值范围在<strong>IntegerCache.low(-128)<strong>到</strong>IntegerCache(127)<strong>之间的就是直接返回，而超过这个范围就直接</strong>new</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String类的理解和创建对象"><a href="#String类的理解和创建对象" class="headerlink" title="String类的理解和创建对象"></a>String类的理解和创建对象</h3><p>（1）String对象用于保存字符串，也就是yyi一组字符串序列。</p><p>（2）字符串常量对象是英文双引号括起的字符串序列。例如：”你好”、”12.97”、”girl”等。</p><p>（3）字符串的字符是使用Unicode字符编码，一个字符（不区分字母还是汉字）占两个字节</p><p>（4）String类常用的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(String original);</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a,<span class="type">int</span> startIndex,<span class="type">int</span> count);</span><br></pre></td></tr></table></figure><p>分析String的源码我们可以发现以下几点：</p><p>①String类实现了<strong>Serializable</strong>说明String是串行化的，可以在在网络中传输。</p><p>②实现了<strong>Comparable</strong>y说明String对象可以相互比较。</p><p>③String是final类，不能被其他的类继承</p><p>④String有属性：<code>private final char value[]</code>用于存放字符串内，这个value因为是final类型，所以不可修改，这里指的是它的地址。</p><h3 id="创建String对象的两种方式"><a href="#创建String对象的两种方式" class="headerlink" title="创建String对象的两种方式"></a>创建String对象的两种方式</h3><p>（1）方式一：直接赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1=<span class="string">&quot;girl&quot;</span>;</span><br></pre></td></tr></table></figure><p>此方法：先从常量池查看是否有”girl”的数据空间，如果有，直接指向; 如果没有则重新创建，然后指向。str1最终指向的是常量池的空间地址。<br>（2）方式二：调用构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;girl&quot;</span>);</span><br></pre></td></tr></table></figure><p>先在堆中创建空间，里面维护了value属性，指向常亮池的girl空间。如果常量池中没有”girl”，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim快速入门</title>
      <link href="/2023/02/12/vim%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2023/02/12/vim%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="vim快速入门"><a href="#vim快速入门" class="headerlink" title="vim快速入门"></a>vim快速入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Linux内置vi文本编辑器，而vim可以看成vi的增强版。它的代码补充、编译以及错误跳转等方便编程的功能非常丰富。vi和vim有三种模式：</p><ul><li>正常模式</li><li>插入模式</li><li>命令行模式</li></ul><h3 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h3><p>用vim打开一个文件就直接进入一般模式了（就是默认模式），在这个模式中你可以使用【<code>上下左右</code>】按键来移动光标，也可以使用【<code>删除字符</code>】或者【<code>删除整行</code>】来处理文档，也可以使用复制粘贴来处理你的文档。</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/67tool.gif" alt="正常模式"></p><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><p>按下<code>i</code>、<code>I</code>、<code>o</code>、<code>O</code>、<code>a</code>、<code>A</code>、<code>r</code>、<code>R</code>等任意一个字母之后才会进入编辑模式，一般来说按<strong>i</strong>即可。</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/Snipaste_2023-03-02_17-13-02.png" alt="插入模式"></p><h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><p>在这个模式中，可以提供你相关指令、完成读取、存盘、替补、离开vim、显示行号等级别</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/Snipaste_2023-03-02_16-25-10%20.png" alt="命令行模式"></p><h3 id="vi和vim的各个模式之间的切换"><a href="#vi和vim的各个模式之间的切换" class="headerlink" title="vi和vim的各个模式之间的切换"></a>vi和vim的各个模式之间的切换</h3><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/vim-vi.png" alt="vi和vim的各个模式切换图"></p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux的目录结构</title>
      <link href="/2023/02/10/linux%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2023/02/10/linux%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h2><p>Linux采用的是极层式的树状目录结构，在此结构中最上层的是根目录“&#x2F;”，然后在此目录下再创建其他的目录。Linux中有一句话：在Linux的世界里面，一切皆文件。</p><p>具体的目录结构如下</p><h3 id="x2F-bin"><a href="#x2F-bin" class="headerlink" title="&#x2F;bin"></a>&#x2F;bin</h3><p>[常用]（&#x2F;usr&#x2F;bin、&#x2F;usr&#x2F;local&#x2F;bin），bin是Binary的缩写，这个目录存放着经常使用的命令。</p><h3 id="x2F-sbin"><a href="#x2F-sbin" class="headerlink" title="&#x2F;sbin"></a>&#x2F;sbin</h3><p>(&#x2F;usr&#x2F;sbin、usr&#x2F;local&#x2F;sbin)，s就是super User的意思，这里存放的是系统管理员使用的系统管理程序。</p><h3 id="x2F-home"><a href="#x2F-home" class="headerlink" title="&#x2F;home"></a>&#x2F;home</h3><p>[常用]存放普通用户的主目录，在 Linux中每一个用户都有一个自己的一个自己的目录，一般目录是以用户的账号名命名。</p><h3 id="x2F-root"><a href="#x2F-root" class="headerlink" title="&#x2F;root"></a>&#x2F;root</h3><p>该目录为系统管理员，也称作超级用户权限者的用户主目录。</p><h3 id="x2F-etc"><a href="#x2F-etc" class="headerlink" title="&#x2F;etc"></a>&#x2F;etc</h3><p>[常用]所需的系统所需要的配置文子目录my.conf</p><h3 id="x2F-usr"><a href="#x2F-usr" class="headerlink" title="&#x2F;usr"></a>&#x2F;usr</h3><p>[常用]这是个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与widows下的program files目录。</p><h3 id="x2F-usr-x2F-local"><a href="#x2F-usr-x2F-local" class="headerlink" title="&#x2F;usr&#x2F;local"></a>&#x2F;usr&#x2F;local</h3><p>这是给主机额外安装软件所安装的目录，一般是通过编译源码的方式安装的程序。</p><h3 id="x2F-boot"><a href="#x2F-boot" class="headerlink" title="&#x2F;boot"></a>&#x2F;boot</h3><p>[常用]存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p><h3 id="x2F-proc"><a href="#x2F-proc" class="headerlink" title="&#x2F;proc"></a>&#x2F;proc</h3><p>这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。</p><h3 id="x2F-srv"><a href="#x2F-srv" class="headerlink" title="&#x2F;srv"></a>&#x2F;srv</h3><p>service缩写，该目录存放的是一些服务启动之后需要提取的数据。</p><h3 id="x2F-sys"><a href="#x2F-sys" class="headerlink" title="&#x2F;sys"></a>&#x2F;sys</h3><p>这是linux2.6内核的一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs</p><h3 id="x2F-tmp"><a href="#x2F-tmp" class="headerlink" title="&#x2F;tmp"></a>&#x2F;tmp</h3><p>这个目录是用来存放一些临时文件</p><h3 id="x2F-dev"><a href="#x2F-dev" class="headerlink" title="&#x2F;dev"></a>&#x2F;dev</h3><p>类似于Windows下的设备管理器，会把所有的硬件用文件的形式存储</p><h3 id="x2F-media"><a href="#x2F-media" class="headerlink" title="&#x2F;media"></a>&#x2F;media</h3><p>Linux会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下</p><h3 id="x2F-mnt"><a href="#x2F-mnt" class="headerlink" title="&#x2F;mnt"></a>&#x2F;mnt</h3><p>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在&#x2F;mnt&#x2F;上，然后就可以进入该目录就可以查看里面的内容了。</p><h3 id="x2F-opt"><a href="#x2F-opt" class="headerlink" title="&#x2F;opt"></a>&#x2F;opt</h3><p>这是给主机额外安装软件所摆放的目录，如安装oracle数据库就可放到该目录下面。默认为空。</p><h3 id="x2F-var"><a href="#x2F-var" class="headerlink" title="&#x2F;var"></a>&#x2F;var</h3><p>习惯将被修改的目录放在这个目录下，包括各种日志文件</p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL连接Mysql报错1251——Client does not support</title>
      <link href="/2023/02/06/SQL%E8%BF%9E%E6%8E%A5Mysql%E6%8A%A5%E9%94%991251%E2%80%94%E2%80%94Client-does-not-support/"/>
      <url>/2023/02/06/SQL%E8%BF%9E%E6%8E%A5Mysql%E6%8A%A5%E9%94%991251%E2%80%94%E2%80%94Client-does-not-support/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天在小主机上试用一下用SQLyog，在连接Mysql数据库时候报错，上网查找解决办法后记录处理过程。</p></blockquote><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>在安装SQLyog后进行测试连接时，弹出如下提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1251 - Client does not support authentication protocol requested by server; consider upgrading MySQL Client</span><br></pre></td></tr></table></figure><p>这句话说客户端不支持服务器请求的身份验证协议；考虑升级MySQL客户端</p><h2 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h2><p>就是加密方式的问题，MySQL 8.0.11换了新的身份验证插件（caching_sha2_password)，而原来的身份验证插件为（mysql_native_password)。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>这里我们更改一下加密方式就行</p><h3 id="进入MySQL数据库"><a href="#进入MySQL数据库" class="headerlink" title="进入MySQL数据库"></a>进入MySQL数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;use mysql;</span><br></pre></td></tr></table></figure><h3 id="查看加密方式"><a href="#查看加密方式" class="headerlink" title="查看加密方式"></a>查看加密方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select user,plugin from user where user=&#x27;root&#x27;;</span><br></pre></td></tr></table></figure><h3 id="更改加密方式"><a href="#更改加密方式" class="headerlink" title="更改加密方式"></a>更改加密方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;alter user &quot;root&quot;@&quot;localhost&quot;identified with mysql_native_password by &quot;(your password)&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令简洁版总结</title>
      <link href="/2023/02/02/git%E5%91%BD%E4%BB%A4%E7%AE%80%E6%B4%81%E7%89%88%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/02/git%E5%91%BD%E4%BB%A4%E7%AE%80%E6%B4%81%E7%89%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里写一个汇总，用到就记录，反复修改，记录一些常见的 git 命令，方便自己反复浏览，[ ]表示参数。</p></blockquote><h2 id="git-配置"><a href="#git-配置" class="headerlink" title="git 配置"></a>git 配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot;#设置提交代码的用户名</span><br><span class="line">git config --global user.email &quot;exmail@example.com&quot;#设置提交代码的邮箱</span><br><span class="line">git config -l 查看当前git环境详细配置</span><br><span class="line">git config --global --list #查看当前用户配置</span><br><span class="line">git config --local --list 查看当前仓库配置信息</span><br></pre></td></tr></table></figure><h2 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init #在当前目录新建一个仓库</span><br><span class="line">git init [repository name]#在指定目录下创建一个新仓库。</span><br></pre></td></tr></table></figure><h2 id="添加到缓存区"><a href="#添加到缓存区" class="headerlink" title="添加到缓存区"></a>添加到缓存区</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add [filename/./--all]#填写filename，指定添加某个文件；git add .则是添加所有文件,但是不会记录删除操作；--all会记录删除操作，如如你在本地删除了xxx.md 这个命令会把删除信息也记录进去，然后在提交的时候把仓库里对应的xxx.md也删除掉，也就是说你在本地做的删除操作会被记录，提交仓库时会删除同样的文件。</span><br></pre></td></tr></table></figure><h2 id="提交到本地仓库"><a href="#提交到本地仓库" class="headerlink" title="提交到本地仓库"></a>提交到本地仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;info&quot; #在提交时我们需要描述一下我们做了什么，info就是我们描述的信息</span><br></pre></td></tr></table></figure><h2 id="查看历史提交日志"><a href="#查看历史提交日志" class="headerlink" title="查看历史提交日志"></a>查看历史提交日志</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline 将日志缩写为单行显示</span><br><span class="line">git log filename #查看指定文件的日志</span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit 查看分支合并情况</span><br><span class="line">git log --oneline --decorate --graph --all 查看分叉历史，包括：提交历史、各个分支的指向以及项目的分支分叉情况。</span><br><span class="line">git log -3 查看最新3条commit日志数据</span><br><span class="line">git reflog 显示操作本地版本库的命令，包括commit和reset等，在回退版本以后又后悔找不到commit id了可以使用此命令查看历史</span><br></pre></td></tr></table></figure><h2 id="回滚代码仓库-git-reset"><a href="#回滚代码仓库-git-reset" class="headerlink" title="回滚代码仓库 git reset"></a>回滚代码仓库 git reset</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard #reset是重置命令，--hard是重置代码仓库版本。这里有几种表述方式</span><br><span class="line">#1.填写哈希id，这个哈希id可以在输入git log的时候去看</span><br><span class="line">#2.回滚当前仓库指向的版本，这里有两个表达，一个是HEAD^，返回到当前仓库的上个版本；另外一个是HEAD~num，num是数字，表示以当前版本为基数，回滚num次。</span><br></pre></td></tr></table></figure><h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git status#查看所有文件状态，A：未修改AM：修改 Untracked：未提交 modified：新文件，但未提交</span><br><span class="line">git status [file-name] #查看指定文件状态</span><br><span class="line">git diff HEAD -- #查看最新本地版本库和工作区所有文件的区别</span><br><span class="line">git diff HEAD -- [file-name] #查看最新本地版本库和工作区文件的却别</span><br><span class="line">git diff HEAD^ -- [file-name] #查看本地上一个版本和工作区文件的却别</span><br><span class="line">git diff [local branch] origin/[remote branch] #比较本地分支和远程分支的区别</span><br></pre></td></tr></table></figure><h2 id="撤回最近一次修改的状态"><a href="#撤回最近一次修改的状态" class="headerlink" title="撤回最近一次修改的状态"></a>撤回最近一次修改的状态</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [url] #用于通过指定的url获取一个代码库</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm [file] #删除工作目录中的文件，并将删除操作添加到stage</span><br></pre></td></tr></table></figure><h2 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a>git show</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show [commit]#显示指定提交的元数据以及内容变更</span><br></pre></td></tr></table></figure><h2 id="分支常用命令"><a href="#分支常用命令" class="headerlink" title="分支常用命令"></a>分支常用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git branch#将会显示当前代码库中所有的本地分支</span><br><span class="line">git branch -r#列出所有远程分支：</span><br><span class="line">git branch 新分支名#新建分支，但还处于当前分支下</span><br><span class="line">git checkout -b 新分支名#新建分支并跳转到该分支下</span><br><span class="line">git merge 新分支名#合并指定分支到当前分支：</span><br><span class="line">git branch -d 分支名#删除分支：</span><br><span class="line">git push origin --delete 分支名#删除远程分支：</span><br></pre></td></tr></table></figure><h2 id="Git-连接到-GitHub"><a href="#Git-连接到-GitHub" class="headerlink" title="Git 连接到 GitHub"></a>Git 连接到 GitHub</h2><p>1.生成 ssh 密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的github邮箱&quot;</span><br></pre></td></tr></table></figure><p>2.验证是否连接成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>3.将本地的仓库连接到远程的 GitHub 仓库（如果有本地仓库）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:username/rep.git</span><br></pre></td></tr></table></figure><p>username 就是你的账户名，rep 就是你的仓库名。</p><p>4.将本地仓库更新内容推送到远程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main #第一次提交加上-u参数，后续不需要</span><br></pre></td></tr></table></figure><p>5.远程拉取新分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin &lt;远程分支名&gt;:&lt;本地分支名&gt; #只拉取不切换</span><br><span class="line">git fetch origin &lt;远程分支名&gt;  #此方式可以将远程分支拉取到本地，不能设置本地分支名，而是直接与远程分支名相同，同时切换到此分支。</span><br></pre></td></tr></table></figure><p>6.拉取代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin &lt;分支名&gt; #拉取远程分支的代码，如果有冲突就先解决冲突再提交代码</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git-bash命令</title>
      <link href="/2023/02/02/git-bash%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/02/02/git-bash%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="git-bash命令"><a href="#git-bash命令" class="headerlink" title="git-bash命令"></a>git-bash命令</h2><h3 id="git-bash简介"><a href="#git-bash简介" class="headerlink" title="git bash简介"></a>git bash简介</h3><p>在开始之前，首先了解<strong>git bash</strong>是什么？</p><blockquote><p>在windows安装<strong>git</strong>时，就会安装<strong>git bash</strong>，<strong>git bash</strong>是windows系统下的命令行工具，基于<strong>msys GNU</strong>环境，有<strong>git</strong>分布式版本控制工具。关于GNU环境，就是和<strong>Linux&#x2F;unix</strong>的环境一样，里面就是我们熟悉的linux工具，<strong>tar、grep、awk</strong>等，并且可以安装编译环境gcc、make等。</p></blockquote><h3 id="git-bash打开操作"><a href="#git-bash打开操作" class="headerlink" title="git bash打开操作"></a>git bash打开操作</h3><p>怎么打开<strong>git bash</strong>打开本地文件夹？</p><p>正常在安装<strong>git</strong>后，你可供选择方式就多了，主要有以下两种：</p><ul><li>不管在桌面找到<strong>Git bash</strong>、还是在<strong>开始</strong>里面，又或者是在搜索里面找到，点击图标就行，运行后使用<strong>cd</strong>命令，输入你想要达到的文件路径就行。(这里注意的点就是使用<strong>cd</strong>命令时使用斜线<strong>“&#x2F;”</strong>，而不是反斜线<strong>“\”</strong>)</li><li>在你想到达的文件路径里面输入<code>git bash</code>就能打开（前提是实现已经把<strong>git bash</strong>添加到<strong>path</strong> 中），又或是在文件空白区域右击选择<strong>GIt Bash Here</strong>，就能直接到你想要到达的文件路径。</li></ul><h3 id="git-bash常见命令"><a href="#git-bash常见命令" class="headerlink" title="git bash常见命令"></a>git bash常见命令</h3><table><thead><tr><th align="center">命令</th><th align="center"><strong>功能</strong></th></tr></thead><tbody><tr><td align="center">touch</td><td align="center">新建文件</td></tr><tr><td align="center">mkdir</td><td align="center">新建目录</td></tr><tr><td align="center">rm</td><td align="center">删除文件</td></tr><tr><td align="center">rm -r</td><td align="center">删除文件夹</td></tr><tr><td align="center">mv</td><td align="center">移动文件夹</td></tr><tr><td align="center">ls</td><td align="center">列出文件夹</td></tr><tr><td align="center">pwd</td><td align="center">打印工作目录</td></tr><tr><td align="center">cd</td><td align="center">改变目录</td></tr><tr><td align="center">reset</td><td align="center">重新初始化终端&#x2F;清屏</td></tr><tr><td align="center">history</td><td align="center">查看命令历史</td></tr><tr><td align="center">help</td><td align="center">帮助</td></tr><tr><td align="center">exit</td><td align="center">退出</td></tr></tbody></table><h3 id="git-bash常见的快捷键"><a href="#git-bash常见的快捷键" class="headerlink" title="git bash常见的快捷键"></a>git bash常见的快捷键</h3><h4 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h4><p>最简单有效的方法就是在<strong>git bash</strong>里面右击，有<code>copy和paste</code>选项。</p><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Ctrl+Shift+C或Ctrl+Insert</td><td align="center">复制</td></tr><tr><td align="center">Ctrl+Shift+S或Shift+Insert</td><td align="center">粘贴</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h4><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Home或Ctrl+A</td><td align="center">跳转至行首</td></tr><tr><td align="center">End或Ctrl+E</td><td align="center">跳转至行尾</td></tr><tr><td align="center">Ctrl+X</td><td align="center">行首&#x2F;当前位置光标跳转</td></tr></tbody></table><p>其他的没有实际用处，这里还有一个<strong>清屏</strong>的快捷键：<code>Ctrl+L</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己的idea配置</title>
      <link href="/2023/01/19/%E8%87%AA%E5%B7%B1%E7%9A%84idea%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/01/19/%E8%87%AA%E5%B7%B1%E7%9A%84idea%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>1.主题是<span style="color:blue">Xcode Theme</span><br>2.加载条是<span style="color:blue">Nyan Progress Bar</span><br>3.文件夹UI包<span style="color:blue">Atom Material icons</span><br>4.智慧代码提示<span style="color:blue">Tabnine AI Code Completion</span></p><h2 id="idea的快捷键"><a href="#idea的快捷键" class="headerlink" title="idea的快捷键"></a>idea的快捷键</h2><table><thead><tr><th align="center">快捷键</th><th align="center">作用</th><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td align="center">Ctrl+F9</td><td align="center">构建&#x2F;编译，相当于【buid project】</td><td>Ctrl +shift+F9</td><td>重新编译当前类</td></tr><tr><td align="center">Ctrl+d</td><td align="center">复制当前行</td><td>Ctrl+shift+c</td><td>复制选中文件路径</td></tr><tr><td align="center">Ctrl+Alt+I</td><td align="center">自动缩进行</td><td>Shift+Enter</td><td>开启新行</td></tr><tr><td align="center">Ctrl + Alt + Enter</td><td align="center">在当前行之前开始新行</td><td>Ctrl + Y</td><td>删除当前行</td></tr><tr><td align="center"><code>Ctrl + Shift + U</code></td><td align="center">大小写转换</td><td>Ctrl+Alt+Shift+Insert</td><td>创建临时文件</td></tr><tr><td align="center">Ctrl+Shift+M</td><td align="center">移动至大括号</td><td>Ctrl+[</td><td>移动到代码块开始</td></tr><tr><td align="center">xxxxxxxxxx git pull origin &lt;分支名&gt; #拉取远程分支的代码，如果有冲突就先解决冲突再提交代码git</td><td align="center">移动到代码块末尾</td><td>Ctrl+Space</td><td>代码补全</td></tr><tr><td align="center">Ctrl+Shift+Enter</td><td align="center">补全当前语句</td><td>Ctrl+Shift+L</td><td>格式化代码</td></tr><tr><td align="center">Ctrl+P</td><td align="center">参数信息提醒</td><td>Ctrl+Q</td><td>快速文档</td></tr><tr><td align="center">Ctrl+Alt+shift+N</td><td align="center">查找符号（变量、方法等）</td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Intellij </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的异常详解</title>
      <link href="/2023/01/18/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/01/18/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是异常"><a href="#1-什么是异常" class="headerlink" title="1.什么是异常?"></a>1.什么是异常?</h2><p>实际工作中，遇到的情况不可能是非常完美的。比如：写一个模块，用户输入的不一定符合要求，程序要打开某个文件，这个文件可能不存在或格式不对，要读数据库的数据，数据可能是空的，程序跑着，内存或者硬盘满了等等。异常指程序运行中出现的不期而至的各种情况。</p><h2 id="２-java中的异常以及分类"><a href="#２-java中的异常以及分类" class="headerlink" title="２.java中的异常以及分类"></a>２.java中的异常以及分类</h2><p>java中把异常当作对象处理，并定义了一个基类<span style="color:blue"> java.lang.Throwable </span>作为所有异常的超类。实际上java把异常分为两类:<span style="color:green">错误(error)</span>和<span style="color:blue">异常(exception)</span></p><p>Exception分支下有一个重要的子类RuntimeException(运行时异常)<br>1.ArrayIndexOutBoundsException(数组下标越界)<br>2.NullPointerException(空指针异常)<br>3.ArithmeticException(算术异常)<br>4.MissingResourceException(丢失资源)<br>5.ClassNotFoundException(找不到类)<br>这些异常是是不检查异常，程序中可以选择捕获处理，也可以不处理。</p><p>Error和Exception的区别：Error通常是灾难性的致命的错误，是程序无法控制和处理的，程序会崩溃，像: JVM系统内部错误、资源耗尽、栈溢出等。当出现这些异常时，Java虚拟机(JVM)一般会选择终止线程；Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</p><h2 id="３异常处理机制"><a href="#３异常处理机制" class="headerlink" title="３异常处理机制"></a>３异常处理机制</h2><h3 id="3-1-try-catch-finally"><a href="#3-1-try-catch-finally" class="headerlink" title="3.1 try-catch-finally"></a>3.1 try-catch-finally</h3><p><span style="color:blue">try-catch-finally</span>程序员在代码中捕获发生的异常，自行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码可能发生异常,如果异常发生了，则异常发生后面的代码不会执行，直接进入catch块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获到异常</span></span><br><span class="line"><span class="comment">     * 1.当异常发生时</span></span><br><span class="line"><span class="comment">     * 2.系统将异常封装成Exception对象e,传递给catch</span></span><br><span class="line"><span class="comment">     * 3.得到异常对象后，程序员自行处理</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//不管try代码块是否有异常发生，始终要执行finally</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">     <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">     String inputStr=<span class="string">&quot;&quot;</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">         inputStr=scanner.next();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            num = Integer.parseInt(inputStr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;你输入的不是一个整数&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-throws"><a href="#3-2-throws" class="headerlink" title="3.2 throws"></a>3.2 throws</h3><p><span style="color:blue">throws</span>将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM。</p><blockquote><p>throws后面的异常类型可以是方法中的异常类型，也可以是它的父类，也可以是异常列表，即可以抛出多个异常</p></blockquote><p>案例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//创建一个文档流对象,这里的文件找不到,显示FileNotFoundExceptionxian编译异常</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://aa.txt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">throws</span> FileNotFoundExceptionxian&#123;</span><br><span class="line">    <span class="comment">//创建一个文档流对象,这里的文件找不到,显示FileNotFoundExceptionxian编译异常</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://aa.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/Exception.png" alt="Exception"></p><h2 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="4.自定义异常"></a>4.自定义异常</h2><p>基本概念：</p><p>程序中出现了某些“错误”，但是该错误并没有在<strong>Throwable</strong>子类中描述处理，这个时候可以设计异常类，用于描述该错误信息。</p><p>在程序中使用自定义异常类，大体可以分为以下几个步骤：</p><ol><li>创建自定义异常类</li><li>在方法中通过throw关键字抛出异常对象(可以通过构造器设置信息)</li><li>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li><li>在出现异常方法的调用者中捕获并处理异常。</li></ol><p>案列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> age=<span class="number">22</span>;</span><br><span class="line">        <span class="comment">//要求年龄到20到35之间,不然抛出自定义异常</span></span><br><span class="line">        <span class="keyword">if</span>(!(age&gt;=<span class="number">20</span>&amp;&amp;age&lt;=<span class="number">35</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄需要在18到120之间&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;你的年龄需要到20到35之间&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-throw和throws的区别"><a href="#5-throw和throws的区别" class="headerlink" title="5.throw和throws的区别"></a>5.throw和throws的区别</h2><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面接</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的赋值机制</title>
      <link href="/2023/01/06/%E6%95%B0%E7%BB%84%E7%9A%84%E8%B5%8B%E5%80%BC%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/01/06/%E6%95%B0%E7%BB%84%E7%9A%84%E8%B5%8B%E5%80%BC%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数组的赋值机制"><a href="#1-数组的赋值机制" class="headerlink" title="1.数组的赋值机制"></a>1.数组的赋值机制</h2><p>基本数据类型赋值，这个值就是具体的数据，而且相互之间不影响。</p><p>eg：int n1&#x3D;2; int n2&#x3D;n1;</p><p>而对于数组而言，数组在默认情况下是引用传递，赋的值是地址。</p><p>下面通个一个案列分析数组赋值的内存图。(ArrayAssign.java)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayAssign</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//基本数据类型赋值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> n1;</span><br><span class="line">        n2 = <span class="number">80</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;n1=&quot;</span>+n1+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;n2=&quot;</span>+n2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组类型赋值</span></span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = arr1;</span><br><span class="line">        arr2[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======arr1的元素=======&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length ; i++) &#123;</span><br><span class="line">            System.out.print(arr1[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;=======arr2的元素=======&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr2.length ; i++) &#123;</span><br><span class="line">            System.out.print(arr2[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n1=10   n2=80</span><br><span class="line">=======arr1的元素=======</span><br><span class="line">10 2 3</span><br><span class="line">========arr2的元素=======</span><br><span class="line">10 2 3</span><br></pre></td></tr></table></figure><p>从而我们得出了：</p><p>（1）基本数据类型赋值，赋值方式为<strong>值拷贝</strong>。所以在这里n2的变化不会影响n1的值。</p><p>（2）数组在默认情况下是<strong>引用传递</strong>，赋的是地址，所以赋值方式是地址拷贝。因为指向的是同一个地址，所以arr2的值的变化会影响到arr1。</p><p>此时的jvm内存情况如下：</p><p><img src="https://lskypro.codeoneday.top/i/2023/08/17/64ddac8feed49.png" alt="数组_JVM情况.png"></p><p><strong>分析：</strong></p><p>运行到基本类型数据赋值时，会在栈里面开辟空间，如n1&#x3D;10。再运行到n2&#x3D;n1时它会把n1的值拷贝一份赋给n2，随后运行n2&#x3D;80时候，通过n2找到它的存储空间，把‘10’修改成‘80’，这个过程中n2的变化不会对n1造成任和影响，这个过程我们称为<strong>值传递</strong>或者叫做<strong>值拷贝</strong>。</p><p>这里进行数组赋值时，会将变量arr1指向一个空间，也就是说它没有直接指向一个值而是<strong>地址</strong>，比如说这个地址是0x0011，而这个地址指向的是堆里面的一个数据空间，如上图右边，这个空间里面分配了三个元素，分别是arr1[0]、arr1[1]、arr1[2]，此时运行到arr2&#x3D;arr1时，它会把arr1指向的地址拷贝一份给arr2，也就是说arr2也指向0x0011这个地址，即通过arr2也能访问这些元素。运行到’arr2[0]&#x3D;10’时，它会通过arr2[0]找到在堆里面分配的空间找到对应的元素，把里面的值改成10，因为arr2和arr1指向的是同一个地址，arr2修改了这个元素，那么也就直接影响到arr1的数据，所以我们将这个过程称为<strong>引用传递</strong>也叫<strong>地址拷贝</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的数组</title>
      <link href="/2023/01/05/Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"/>
      <url>/2023/01/05/Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数组介绍"><a href="#1-数组介绍" class="headerlink" title="1.数组介绍"></a>1.数组介绍</h2><ul><li>数组是相同类型数据（数据类型可以为任何类型）的有序集合，就是说数组可以存放多个同一类型的数据。</li><li>数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成</li><li>每一个数据成为一个数组元素，每个数组元素可以通过一个下标来访问他们；数组的下标从 0 开始的，下标的合法区间：[0,length-1]</li><li>数组长度的确定，不可变的。越界报错：ArrayIndexOutofBoundsException</li></ul><h2 id="2-数组的声明"><a href="#2-数组的声明" class="headerlink" title="2. 数组的声明"></a>2. 数组的声明</h2><ul><li>先声明数组变量，才使用数组<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a;   <span class="comment">//或者 </span></span><br><span class="line"><span class="type">int</span> a[];</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>使用new操作符来创建数组<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-数组的特点"><a href="#3-数组的特点" class="headerlink" title="3.数组的特点"></a>3.数组的特点</h2><p>1.长度是确定的，数组一旦被创建，它的大小就是不可以改变的。</p><p>2.元素必须是相同的类型，不允许出现混合类型</p><p>3.数组变量属于引用类型，数组也可以看成是对象，数组中 每个元素相当于该对象的成员变量</p><p>4.数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象理性，数组对象本身是在堆中的这一点可以看后面的<a href="https://lkfhnust18.github.io/LKFhnust18/2023/01/06/%E6%95%B0%E7%BB%84%E7%9A%84%E8%B5%8B%E5%80%BC%E6%9C%BA%E5%88%B6/">数组的赋值机制</a></p><h2 id="4-数组的使用"><a href="#4-数组的使用" class="headerlink" title="4.数组的使用"></a>4.数组的使用</h2><p>打印全部的数组元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array01=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array01.length;i++)&#123;</span><br><span class="line">    System.out.println(array01[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//jdk1.5之后出现增强for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> array : array01)&#123;</span><br><span class="line">    System.out.println(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反转数组元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array02=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[array02.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=result.length-<span class="number">1</span>;i&lt;array.length;i++,j--)&#123;</span><br><span class="line">    result[j]=array02[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><p>冒泡排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array03=&#123;<span class="number">32</span>,<span class="number">44</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="type">int</span> max;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array03.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;array03.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(array03[j]&gt;array03[j+<span class="number">1</span>])&#123;</span><br><span class="line">           max=array03[j];</span><br><span class="line">           array03[j]=array03[j+<span class="number">1</span>];</span><br><span class="line">           array03[j+<span class="number">1</span>]=max;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(array03);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WireShark复习以及常见的协议包抓取</title>
      <link href="/2022/01/25/WireShark%E5%A4%8D%E4%B9%A0%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%8C%85%E6%8A%93%E5%8F%96/"/>
      <url>/2022/01/25/WireShark%E5%A4%8D%E4%B9%A0%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%8C%85%E6%8A%93%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1-WireShark介绍"><a href="#1-WireShark介绍" class="headerlink" title="1.WireShark介绍"></a>1.WireShark介绍</h2><p>WireShark是一个网络包分析工具。该工具主要用来捕获网络数据包，并自动解析数据包，为用户显示数据包的详细信息，供用户对数据包进行分析。官网地址：<a href="https://www.wireshark.org/">https://www.wireshark.org/</a></p><h2 id="2-WireShark抓包原理"><a href="#2-WireShark抓包原理" class="headerlink" title="2.WireShark抓包原理"></a>2.WireShark抓包原理</h2><p>Wireshark使用的环境大致分为两种，一种是电脑直连互联网的单机环境，另外一种就是应用比较多的互联网环境，也就是连接交换机的情况。</p><p>「单机情况」下，Wireshark直接抓取本机网卡的网络流量；<br>「交换机情况」下，Wireshark通过端口镜像、ARP欺骗等方式获取局域网中的网络流量。</p><ul><li>端口镜像：利用交换机的接口，将局域网的网络流量转发到指定电脑的网卡上。</li><li>ARP欺骗：交换机根据MAC地址转发数据，伪装其他终端的MAC地址，从而获取局域网的网络流量。</li></ul><h2 id="3-WireShark快速入门"><a href="#3-WireShark快速入门" class="headerlink" title="3.WireShark快速入门"></a>3.WireShark快速入门</h2><h3 id="3-1-选择网卡"><a href="#3-1-选择网卡" class="headerlink" title="3.1.选择网卡"></a>3.1.选择网卡</h3><p>打开WireShark后，会直接进入【网卡选择界面】，如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/20230616100532.png" alt="wireshark-网卡选择"></p><p><span style="color:blue">WLAN</span>是我本地主机的无线网卡，双击网卡名，它会自动开始抓取这个网卡的流量。</p><h3 id="3-2-界面介绍以及常见操作"><a href="#3-2-界面介绍以及常见操作" class="headerlink" title="3.2 界面介绍以及常见操作"></a>3.2 界面介绍以及常见操作</h3><p>WireShark大致可以分为六个区域：</p><table><thead><tr><th>区域</th><th>功能</th></tr></thead><tbody><tr><td>菜单栏</td><td>用于调试、配置</td></tr><tr><td>快捷菜单栏(工具栏)</td><td>常用功能的快捷方式</td></tr><tr><td>过滤栏(过滤器)</td><td>定过滤条件，过滤数据包</td></tr><tr><td>数据包列表</td><td>核心区域，每一行就是一个数据包</td></tr><tr><td>数据包详情</td><td>数据包的详细数据</td></tr><tr><td>数据包字节</td><td>数据包对应的字节流，二进制</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/20230616102749.png" alt="WireShark界面"></p><p>在</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/yuanyuzhou/p/16308963.html">WireShark零基础使用教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WireShark </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
