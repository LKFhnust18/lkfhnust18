<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql命令大全</title>
      <link href="/2023/06/21/mysql%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2023/06/21/mysql%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">显示可用数据库的一个列表</span><br><span class="line">show databases;</span><br><span class="line">选择操作数据库</span><br><span class="line">use database;</span><br><span class="line">获取一个数据库内的表的列表</span><br><span class="line">show tables;</span><br><span class="line">对于表table_name的每一个字段返回一行，行内包括段名、数据类型、是否允许NuLL、键信息、默认值以及其他信息。</span><br><span class="line">shoW columns from table_name;</span><br></pre></td></tr></table></figure><p>检索数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">检索单个列的数据,返回表table_name内中的column_name这一列的数据</span><br><span class="line">select column_name from table_name; </span><br><span class="line">从一个表中检索多个列，返回表table_name内列名为column_name1、column_name2、column_name3的数据</span><br><span class="line">select column_name1,column_name2,column_name3 from table_name;</span><br><span class="line">检索所有列的数据，返回表table_name内所有列的数据</span><br><span class="line">select * from table_name;</span><br><span class="line">检索唯一的数据(意思就是除去重复的项)，返会表table_name内列名colum_name下唯一的数据</span><br><span class="line">select distinct column_name from table_name;</span><br><span class="line">限制返回结果，返回表table_name内列名column_name的前number行，limit number表示返回不多于number行，且从第一行开始返回数据</span><br><span class="line">select column_name from table_name limit number; </span><br><span class="line">限制返回结果并且指定行，limit number1,number2,需要注意的是第一行是行0而不是行1，所以limit 1,1检索的是第二行而不是第一行</span><br><span class="line">select column_name from table_name limit number1,number2;</span><br><span class="line">使用完全限定的名字引用列（同时使用表名和列名）</span><br><span class="line">select table_name.column_name from table_name;</span><br><span class="line">使用完全限定的名字引用列和表</span><br><span class="line">select tabele_name.column_name from database_name.table_name;</span><br></pre></td></tr></table></figure><p>排序检索数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">默认排序(默认升序)</span><br><span class="line">select column_name from table_name order by column_name;</span><br><span class="line">按多个列排序,首先按column_name2排序，然后按column_name3排序</span><br><span class="line">select column_name1,column_name2,column_name3 from table_name order by column_name2,column_name3;</span><br><span class="line">指定排序方向，desc关键字表降序,asc表示升序</span><br><span class="line">select column_name1,column_name2,column_name3 from table_name order by column_name2 desc;</span><br><span class="line">多列排序中指定排序，如果只是在某个列降序排序，仅仅对它指定desc关键字就行;反之，想对多个列进行降序排序，必须对每个列指定desc关键字。</span><br><span class="line">select column_name1,column_name2,column_name3 from table_name order by column_name2 desc,column_name;</span><br><span class="line">select column_name1 desc,column_name2 desc;</span><br></pre></td></tr></table></figure><p>过滤数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用where子句</span><br><span class="line">select column_name1,column_name2 from table_name where cloumn_name=xxx;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础-泛型</title>
      <link href="/2023/06/16/Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/06/16/Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是泛型？"><a href="#1-什么是泛型？" class="headerlink" title="1.什么是泛型？"></a>1.什么是泛型？</h2><pre><code>Java推出泛型之前，程序员可以构建一个元素类型为Object的集合，虽然可以储存任意的数据类型对象，但是需要程序员知道存储，每个元素的数据类型，否则很容易引发**ClassCastException**异常。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven基础学习笔记回顾</title>
      <link href="/2023/06/09/maven%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9E%E9%A1%BE/"/>
      <url>/2023/06/09/maven%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="1、为什么学习Maven"><a href="#1、为什么学习Maven" class="headerlink" title="1、为什么学习Maven?"></a>1、为什么学习Maven?</h2><h3 id="1-1、Maven作为依赖管理工具"><a href="#1-1、Maven作为依赖管理工具" class="headerlink" title="1.1、Maven作为依赖管理工具"></a>1.1、Maven作为依赖管理工具</h3><p>①jar包的规模<br>在javaWeb阶段也用到jar包，不过基本上主要还是用原生api开发，没有经过框架封装整合。随着我们使用越来越多的框架，项目中的jar包也越来越多。<br>②jar包的来源</p><ul><li><p>jar包所属的技术的网站，网站通常是英文界面，网站的结构又不尽相同，甚至找到下载链接还发现需要通过特殊的工具下载</p></li><li><p>第三方网站提供下载。问题是不规范，在使用过程中会出现各种问题。</p><ul><li>jar包的名称</li><li>jar包的版本</li><li>jar包内的具体细节</li></ul></li><li><p>而使用maven后，依赖对应的包能自动下载，方便，快捷又规范。</p></li></ul><h3 id="1-2、Maven作为构建管理工具"><a href="#1-2、Maven作为构建管理工具" class="headerlink" title="1.2、Maven作为构建管理工具"></a>1.2、Maven作为构建管理工具</h3><p>  一个主要的原因就是脱离了IDE环境任需要构建，在部署到远程端时，不可能在远程端也下载一个IDE；其次互联网的更新非常平凡，经常有新功能要去发布。常见的部署过程如下；</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/20230609170644.png" alt="img"></p><h2 id="2、什么是Maven"><a href="#2、什么是Maven" class="headerlink" title="2、什么是Maven?"></a>2、什么是Maven?</h2><p>Maven是Apache软件基金会组织维护的一款专门为Java项目提供<span style="color:blue">构建</span>和<span style="color:blue">依赖</span>管理支持的工具。</p><h3 id="2-1、那什么是构建？"><a href="#2-1、那什么是构建？" class="headerlink" title="2.1、那什么是构建？"></a>2.1、那什么是构建？</h3><p>构建指的是在java项目开发中使用[原材料生产产品]的过程。</p><ul><li><p>原材料</p><ul><li>java源代码</li><li>基于HTML的Thymeleaf文件</li><li>图片</li><li>配置文件</li><li>……</li></ul></li><li><p>产品</p><ul><li>一个可以在服务器上运行的项目</li></ul></li></ul><p>构建过程包含的主要的环节：</p><ul><li>删除上一次构建的结果，为下一次构建做好准备</li><li>编译：java源程序编译成**.class**字节码文件</li><li>测试：运行提前准备好的测试程序</li><li>报告：针对刚才测试的结果生成一个全面的信息</li><li>打包：<ul><li>Java工具：jar包</li><li>Web工程：war包</li></ul></li><li>安装：把一个Maven工程经过打包操作生成的jar包或War包安装到Maven仓库</li><li>部署：将准备好的jar包或war包部署到服务器上运行。</li></ul><h3 id="2-2、那什么是依赖？"><a href="#2-2、那什么是依赖？" class="headerlink" title="2.2、那什么是依赖？"></a>2.2、那什么是依赖？</h3><p>如果A工程用到了B工程的类、接口、配置文件这样的资源，那么我们就可以说A依赖于B，例如：</p><p>junit-4.12依赖hamcrest-core-1.3</p><p>依赖管理中需要解决的具体问题</p><ul><li>jar包的下载：使用Maven之后，jar包会从规范的远程仓库下载到本地。</li><li>jar包之间的依赖：通过依赖的传递性自动完成。</li><li>jar包之间的冲突：通过对依赖的配置进行调整，让某些jar包不会被导入。</li></ul><h3 id="2-3、Maven的工作机制"><a href="#2-3、Maven的工作机制" class="headerlink" title="2.3、Maven的工作机制"></a>2.3、Maven的工作机制</h3><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/image-20230613094524250.png" alt="image-20230613094524250"></p><h2 id="3、Maven核心程序配置"><a href="#3、Maven核心程序配置" class="headerlink" title="3、Maven核心程序配置"></a>3、Maven核心程序配置</h2><p>首先要下载maven程序，我下载的版本是3.6.3。</p><h3 id="3-1、第一步：解压Maven核心程序"><a href="#3-1、第一步：解压Maven核心程序" class="headerlink" title="3.1、第一步：解压Maven核心程序"></a>3.1、第一步：解压Maven核心程序</h3><p>就如我的核心程序压缩包：apache-maven-3.6.3，解压到<strong>非中文</strong>、<strong>没有空格</strong>的目录。例如：</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/image-20230613095413013.png" alt="image-20230613095413013"></p><p>在解压目录中，我们需要着重看关心Macen的<strong>核心配置文件：conf&#x2F;settings.xml</strong></p><h3 id="3-2、第二步：指定本地仓库"><a href="#3-2、第二步：指定本地仓库" class="headerlink" title="3.2、第二步：指定本地仓库"></a>3.2、第二步：指定本地仓库</h3><p>本地仓库默认值:用户home目录&#x2F;.m2&#x2F;repository。 由于本地仓库的默认位置是在用户的home目录下，而home目录往往在C盘，也就是系统盘。将来Maven仓库中jar包越来越多,仓库体积越来越大，可能会拖慢C盘运行速度,<br>响系统性能。所以建议将Maven的本地仓库放在其他盘符下。配置方式如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">   | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>F:\maven\repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-3、配置阿里云提供的镜像仓库"><a href="#3-3、配置阿里云提供的镜像仓库" class="headerlink" title="3.3、配置阿里云提供的镜像仓库"></a>3.3、配置阿里云提供的镜像仓库</h3><p>Maven下载jar包默认访问境外的中央仓库，而国外网站速度很慢。改成阿里云提供的镜像仓库，访问国内网站<br>，可以让Maven下载jar包的时候速度更快。配置的方式是:将下面mirror标签整体复制到settings.xml文件<br>的mirrors标签的内部。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-4、配置Maven工程的基础JDK版本"><a href="#3-4、配置Maven工程的基础JDK版本" class="headerlink" title="3.4、配置Maven工程的基础JDK版本"></a>3.4、配置Maven工程的基础JDK版本</h3><p>如果按照默认配置运行，Java工程使用的默认JDK版本是1.5,而我们熟悉和常用的是JDK 1.8版本。修改配置的<br>方式是:将profile标签整个复制到settings.xml文件的profiles标签内。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">profiles</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-5、配置环境变量"><a href="#3-5、配置环境变量" class="headerlink" title="3.5、配置环境变量"></a>3.5、配置环境变量</h3><h4 id="3-5-1、检查JAVA-HOME配置"><a href="#3-5-1、检查JAVA-HOME配置" class="headerlink" title="3.5.1、检查JAVA_HOME配置"></a>3.5.1、检查JAVA_HOME配置</h4><p>Maven是一个Java语言开发的程序，它必须基于JDK来运行，需要通过JAVA_HOME来找到jdk的安装位置。</p><p>下图是我的配置：</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/image-20230613110146502.png" alt="image-20230613110146502"></p><p>可以在命令行输入下列命令验证：</p><ul><li>java -version</li><li>echo %JAVA_HOME%</li><li>echo %PATH%</li></ul><h4 id="3-5-2、配置MAVEN-HOME"><a href="#3-5-2、配置MAVEN-HOME" class="headerlink" title="3.5.2、配置MAVEN_HOME"></a>3.5.2、配置MAVEN_HOME</h4><p>新建“MAVEN_HOME”变量，在变量值一栏输入你的maven核心程序包解压的目录。</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/image-20230613111035099.png" alt="image-20230613111035099"></p><h4 id="3-5-3、配置Path"><a href="#3-5-3、配置Path" class="headerlink" title="3.5.3、配置Path"></a>3.5.3、配置Path</h4><p>选中“Path”变量，在变量值的最前面或者最后面添加“;MAVEN_HOME%\bin;”</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/image-20230613111257482.png" alt="image-20230613111257482"></p><p>验证：在命令行输入mvn -v</p><h2 id="4、根据坐标创建Maven工程"><a href="#4、根据坐标创建Maven工程" class="headerlink" title="4、根据坐标创建Maven工程"></a>4、根据坐标创建Maven工程</h2><h3 id="4-1、Maven核心概念：坐标"><a href="#4-1、Maven核心概念：坐标" class="headerlink" title="4.1、Maven核心概念：坐标"></a>4.1、Maven核心概念：坐标</h3><p>①数学中的坐标使用x，y，z三个作为 <span style="color:blue"> <strong>向量</strong>  </span>作为空间的坐标系，可以在 <span style="color:blue"><strong>空间</strong></span>中的唯一的定位到一个 <span style="color:blue"><strong>点</strong></span>。</p><p>②Maven中的坐标：</p><p>   [1]向量说明<br>使用三个<span style="color:blue"><strong>向量</strong> </span>在 <span style="color:blue"><strong>Maven的仓库</strong> </span>中唯一的定位一个 <span style="color:blue"><strong>jar</strong> </span>包</p><ul><li><span style="color:blue"> <strong>groupId</strong> </span>：公司或组织的id</li><li><span style="color:blue"><strong>artifactId</strong> </span>：一个项目或者是项目中的一个模块的id</li><li><span style="color:blue"> <strong>version</strong> </span>：版本号</li></ul><h3 id="4-2、三个向量取值方式"><a href="#4-2、三个向量取值方式" class="headerlink" title="4.2、三个向量取值方式"></a>4.2、三个向量取值方式</h3><ul><li><p>groupId：公司或组织域名的倒序，通常也会加上项目名称</p><ul><li>例如：com.aliyun.maven</li></ul></li><li><p>artifactId：模块的名称，将来作为Maven工程的工程名</p></li><li><p>version：模块的版本号，根据自己的需求设定</p><ul><li>例如：SNAPSHOT表示快照版本，正在</li><li>例如：RELEASE表示正式版本</li></ul></li></ul><p>eg：</p><ul><li>groupId：com.atguigu.maven</li><li>artifactId：pro01-atguigu-maven</li><li>version：1.0-SNAPSHOT</li></ul><h3 id="4-3、坐标和仓库中jar包的存储路径之间的对应关系"><a href="#4-3、坐标和仓库中jar包的存储路径之间的对应关系" class="headerlink" title="4.3、坐标和仓库中jar包的存储路径之间的对应关系"></a>4.3、坐标和仓库中jar包的存储路径之间的对应关系</h3><p>坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据坐标在本地仓库找到对应的jar包</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Maven本地仓库根目录\javaX\servlet\servlet-api\2.5\servlet-api-2.5.jar</span><br></pre></td></tr></table></figure><h3 id="4-4、实际操作过程"><a href="#4-4、实际操作过程" class="headerlink" title="4.4、实际操作过程"></a>4.4、实际操作过程</h3><h4 id="4-4-1、创建工作区间"><a href="#4-4-1、创建工作区间" class="headerlink" title="4.4.1、创建工作区间"></a>4.4.1、创建工作区间</h4><p>例如：我们现在的工作区间目录是：F:\maven-space\mave-programe01</p><p>在工作区间目录打开命令行或在命令行下切换至工作区间目录</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/image-20230614095308948.png" alt="image-20230614095308948"></p><h4 id="4-4-2、使用命令生成Maven工程"><a href="#4-4-2、使用命令生成Maven工程" class="headerlink" title="4.4.2、使用命令生成Maven工程"></a>4.4.2、使用命令生成Maven工程</h4><p>运行 <span style="color:blue">mvn archetype:generate</span> 命令，其中<code>mvn</code>是<strong>主命令</strong> ，<code>archetype:generate</code>是 <strong>子命令</strong>，在其中<code>archetype</code>是<strong>插件</strong>，而<code>generate</code>是<strong>目标</strong>。</p><p>在运行过程中命令行显示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Choose a number or apply filter(format:[groupId:]artifactId,case sensitive contains):7:</span><br><span class="line">//直接回车，使用默认值</span><br><span class="line">Define value for property &#x27;groupId&#x27;://输入公司或组织域名+项目名称 例如：com.atguigu.maven</span><br><span class="line">Define value for property &#x27;artifactId&#x27;://输入模块名称  例如：pro01-maven-java</span><br><span class="line">Define value for property &#x27;version&#x27; 1.0-SNAPSHOT:: //直接回车，使用默认值</span><br><span class="line">Define value for property &#x27;package&#x27; com.atguigu.maven:: //直接回车，使用默认值</span><br><span class="line">Confirm properties configuration:...//这里会根据你前面输入的内容生成信息要你确认，直接回车，表示确认。如果前面有输入错误，想要重新输入，则输入N再回车。</span><br></pre></td></tr></table></figure><p>结果示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/image-20230614114221753.png" alt="maven-program-result"></p><h4 id="4-4-3、调整junit版本"><a href="#4-4-3、调整junit版本" class="headerlink" title="4.4.3、调整junit版本"></a>4.4.3、调整junit版本</h4><p>Maven默认生成的工程，是对junit依赖比较低的3.8.1版本，我们可以改成较合适的4.12版本，自动生成的App.java和AppTest.java可以删除。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--依赖信息配置--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- dependencies复数标签：里面包含dependency单数标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- depenency单数标签：配置一个具体的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 通过坐标来依赖其他jar包--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-4-4、pom-xml的含义"><a href="#4-4-4、pom-xml的含义" class="headerlink" title="4.4.4、pom.xml的含义"></a>4.4.4、pom.xml的含义</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span style="color: blue">porject</span>是根标签，表示对当前工程进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span style="color: blue">modelVersion</span>从Maven 2开始就是4.0.0</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些就是前面我们介绍的坐标信息</p><ul><li><span style="color: blue">groupId标签</span>：坐标向量之一，代表公司或组织开发的的某一个项目</li><li><span style="color: blue">artifactId标签</span>：坐标向量之一，代表项目下的某一个模块。</li><li><span style="color: blue">version标签</span>：坐标向量之一，代表当前模块的版本</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span style="color: blue">packaging标签</span>：打包方式</p><p> 1.取值<strong>jar</strong>：生成jar包，说明这是一个<strong>Java</strong>工程。</p><p> 2.取值<strong>war</strong>：生成war包，说明这是一个Web工程。</p><p>3.取值<strong>pom</strong>，说明这个工程是用来管理其他工程的工程。</p><h3 id="4-5、Maven的核心概念：POM"><a href="#4-5、Maven的核心概念：POM" class="headerlink" title="4.5、Maven的核心概念：POM"></a>4.5、Maven的核心概念：POM</h3><h4 id="4-5-1、POM的含义"><a href="#4-5-1、POM的含义" class="headerlink" title="4.5.1、POM的含义"></a>4.5.1、POM的含义</h4><p>POM: Project Object Model，项目对象模型。和POM类似的是: DOM (Document Object Model)，文档对<br>象模型。它们都是模型化思想的具体体现。</p><h4 id="4-5-2、模型化思想"><a href="#4-5-2、模型化思想" class="headerlink" title="4.5.2、模型化思想"></a>4.5.2、模型化思想</h4><p>POM表示将工程抽象为一个模型,再用程序中的对象来描述这个模型。这样我们就可以用程序来管理项目了。我<br>们在开发过程中，最基本的做法就是将现实生活中的事物抽象为模型,然后封装模型相关的数据作为一个对象，这<br>样就可以在程序中计算与现实事物相关的数据。</p><h4 id="4-5-3、对应的配置文件"><a href="#4-5-3、对应的配置文件" class="headerlink" title="4.5.3、对应的配置文件"></a>4.5.3、对应的配置文件</h4><p>POM理念集中体现在Maven工程根目录下pom.xml这个配置文件中。所以这个pom.xml配置文件就是Pom理念集中体现在maven工程根目录下po.xml这个配置文件中。所以这个po.xml配置文件就是<br>Maven工程的核心配置文件。其实学习Maven就是学这个文件怎么配置，各个配置有什么用。Maven工程的核心配置文件.其实学习Maven就是学这个文件怎么配置，各个配置有什么用。</p><h3 id="4-6、Maven的核心概念：约定的目录结构"><a href="#4-6、Maven的核心概念：约定的目录结构" class="headerlink" title="4.6、Maven的核心概念：约定的目录结构"></a>4.6、Maven的核心概念：约定的目录结构</h3><h4 id="4-6-1、各个目录的作用"><a href="#4-6-1、各个目录的作用" class="headerlink" title="4.6.1、各个目录的作用"></a>4.6.1、各个目录的作用</h4><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/20230614161520.png" alt="img-Maven-dir"></p><p>还有一个target目录专门存放构建操作输出的结果。</p><h4 id="4-6-2、约定目录结构的意义"><a href="#4-6-2、约定目录结构的意义" class="headerlink" title="4.6.2、约定目录结构的意义"></a>4.6.2、约定目录结构的意义</h4><p>Maven为了让构建过程能够尽可能自动化完成，所以必须约定目录结构的作用。例如: Maven 执行编译操作,必<br>须先去Java源程序目录读取Java源代码,然后执行编译，最后把编译结果存放在target目录。</p><h2 id="5、在Maven工程中编写代码"><a href="#5、在Maven工程中编写代码" class="headerlink" title="5、在Maven工程中编写代码"></a>5、在Maven工程中编写代码</h2><h3 id="5-1、主体程序"><a href="#5-1、主体程序" class="headerlink" title="5.1、主体程序"></a>5.1、主体程序</h3><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/20230614165605.png" alt="img-main-programe"></p><p>主体程序指的是被测试的程序，同时也是将来在项目中真正要使用的程序。</p><h2 id="6、执行Maven的构建命令"><a href="#6、执行Maven的构建命令" class="headerlink" title="6、执行Maven的构建命令"></a>6、执行Maven的构建命令</h2><h3 id="6-1、前提要求"><a href="#6-1、前提要求" class="headerlink" title="6.1、前提要求"></a>6.1、前提要求</h3><p>运行<strong>Maven</strong>中和构建操作相关的命令时，必须进入到<span style="color:blue">pom.xml</span>所在的目录。如果没有在<span style="color:blue">pom.xml</span>所在的目录运<br>行Maven的构建命令,那么会看到下面的错误信息:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The goa1 you specified requires a project to execute but there is no POM in this</span><br><span class="line">directory</span><br></pre></td></tr></table></figure><p>tip:</p><p>mvn -V命令和构建操作无关，只要正确配置了PATH,在任何目录下执行都可以。而构建相关的命令要在<br>pom.xml所在目录下运行一– 操作哪个工程，就进入这个工程的pom.xml目录。</p><h3 id="6-2、清除操作"><a href="#6-2、清除操作" class="headerlink" title="6.2、清除操作"></a>6.2、清除操作</h3><p><span style="color:blue">mvn clean</span></p><p>效果：删除target目录</p><h3 id="6-3、编译操作"><a href="#6-3、编译操作" class="headerlink" title="6.3、编译操作"></a>6.3、编译操作</h3><p>主程序编译：<span style="color:blue">mvn compile</span></p><p>测试程序编译：<span style="color:blue">mvn test-compile</span></p><p>主程序编译结果存放目录：<span style="color:blue">target&#x2F;classes</span></p><p>测试程序编译结果存放的目录：<span style="color:blue">target&#x2F;test-clsses</span></p><h3 id="6-4、测试操作"><a href="#6-4、测试操作" class="headerlink" title="6.4、测试操作"></a>6.4、测试操作</h3><p><span style="color:blue">mvn test</span>——测试结果存放目录：target&#x2F;surefire-reports</p><h3 id="6-5、打包操作"><a href="#6-5、打包操作" class="headerlink" title="6.5、打包操作"></a>6.5、打包操作</h3><p><span style="color: blue">mvn package</span>——打包的结果——jar包，存放的目录：target</p><h3 id="6-6、安装操作"><a href="#6-6、安装操作" class="headerlink" title="6.6、安装操作"></a>6.6、安装操作</h3><p><span style="color:blue">mvn install</span></p><p>安装的效果是将本地构建过程中生成的jar包存入Maven本地仓库。这个jar包在Maven仓库中的路径是根据它的坐标生成的。</p><p>另外，安装操作会将pom.xml文件转换成XXX.pom文件一起存入本地仓库。所以我们在Maven的本地仓库中想看一个jar包原始的pom.xml文件时候，查看对应XXX.pom文件即可，它们是名字发生了改变，本质上是一个文件。</p><h2 id="7、创建Maven版的Web工程"><a href="#7、创建Maven版的Web工程" class="headerlink" title="7、创建Maven版的Web工程"></a>7、创建Maven版的Web工程</h2><h3 id="7-1、说明"><a href="#7-1、说明" class="headerlink" title="7.1、说明"></a>7.1、说明</h3><p>使用<span style="color: blue">mvn archetype:generate</span>命令生成Web工程时，需要使用一个专门的archetype。这个专门生成Web工程骨架的archtype可以参照官网看到它的用法。</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/20230615102813.png" alt="maven版的WEB工程"></p><p>参数<strong>archetypeGroupId</strong>、<strong>archetypeArtifactId</strong>、<strong>achetypeVersion</strong>用来指定<span style="color:blue">maven-archetype-webapp</span>的坐标。</p><h3 id="7-2、操作流程"><a href="#7-2、操作流程" class="headerlink" title="7.2、操作流程"></a>7.2、操作流程</h3><p><span style="color : red">注意：</span>不能在一个非pom的工程下面再创建其他工程，所以回到工作空间根目录来操作。</p><h4 id="7-2-1、运行生成工程的命令："><a href="#7-2-1、运行生成工程的命令：" class="headerlink" title="7.2.1、运行生成工程的命令："></a>7.2.1、运行生成工程的命令：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp </span><br></pre></td></tr></table></figure><p>接下来的操作同上面创建Maven工程。</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20230615104638702.png" alt="image-20230615104638702"></p><p>这里再确认一下生成的pom.xml，确认打包的方式是war包方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>生成的Web工程的目录结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/20230615104956.png" alt="img-web目录"></p><p>web-app目录下有index.jsp</p><p>WEB-INF目录下有web.xml</p><h4 id="7-2-2、创建Servlet"><a href="#7-2-2、创建Servlet" class="headerlink" title="7.2.2、创建Servlet"></a>7.2.2、创建Servlet</h4><p>①在main目录下创建java目录</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20230615105543436.png" alt="创建java目录"></p><p>②在java目录下创建Servlet类所在的包的目录</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/20230615105810.png" alt="创建servlet类所在的包"></p><p>③在包下创建Servlet类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HtttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponce;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServelet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException,IOException&#123;</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;hello maven web&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④在web.xml中注册Servlet</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>helloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.maven.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>helloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/helloServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>⑤在index.jsp页面编写超链接</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">            Hello World!</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;helloServlet&quot;</span>&gt;Access Servlet&lt;/a&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>⑥编译</p><p>运行<code>mvn compile</code>命令。</p><p>tip:</p><p>如果出现程序包xxx不存在，说明你引入的类属于的xxx包，所以你的Web工程需要依赖这个xxx包。比如前面我引入<strong>HttpServlet</strong>这个类，而这个类属于<strong>servlet-api.jar</strong>这个jar包，此说我们就说我们的这个Web工程需要依赖<strong>servlet-api.jar</strong>包。</p><p><strong>那我们如何知道依赖哪个包的呢？</strong></p><p>可以通过<a href="https://mvnrepository.com/">MVNREPOSITORY</a>这个网站查询</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/20230615114843.png" alt="mvn-repository"></p><h2 id="8、让WEB工程依赖java工程"><a href="#8、让WEB工程依赖java工程" class="headerlink" title="8、让WEB工程依赖java工程"></a>8、让WEB工程依赖java工程</h2><p>tip：只有Web工程依赖java工程，没有反过来java工程依赖Web工程，本质上来说Web工程依赖的java工程其实就是Web工程导入的jar包，最终java工程会变成jar包，放在Web工程的<span style="color :  blue">WEbB-INF&#x2F;lib</span>目录下。</p><h3 id="8-1、配置依赖"><a href="#8-1、配置依赖" class="headerlink" title="8.1、配置依赖"></a>8.1、配置依赖</h3><p>在pom-maven-web工程的pom.xml，找到<strong>dependencies</strong>标签，在<strong>dependencies</strong>标签中做如下的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置对Java工程pro01-maven-java --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体的方式是：在dependency标签内使用坐标实现依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-2、在Web工程中，编写测试代码"><a href="#8-2、在Web工程中，编写测试代码" class="headerlink" title="8.2、在Web工程中，编写测试代码"></a>8.2、在Web工程中，编写测试代码</h3><p>①补充创建目录</p><p>pro02-maven-web\src\<span style="color:blue">test\java\com\atguigu\maven </span> </p><p>②确认Web工程依赖了<strong>junit</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>③创建测试类</p><p>创建测试类到pro02-maven-web\<span style="color:blue">src\test\java\com\atguigu\maven</span>目录下</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github+picgo搭建markdown图床</title>
      <link href="/2023/02/28/github-picgo%E6%90%AD%E5%BB%BAmarkdown%E5%9B%BE%E5%BA%8A/"/>
      <url>/2023/02/28/github-picgo%E6%90%AD%E5%BB%BAmarkdown%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="github-picgo-搭建-markdown-图床"><a href="#github-picgo-搭建-markdown-图床" class="headerlink" title="github+picgo 搭建 markdown 图床"></a>github+picgo 搭建 markdown 图床</h2><h3 id="GitHub配置"><a href="#GitHub配置" class="headerlink" title="GitHub配置"></a>GitHub配置</h3><h4 id="建立一个仓库，必须为public"><a href="#建立一个仓库，必须为public" class="headerlink" title="建立一个仓库，必须为public"></a>建立一个仓库，必须为public<img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/0fd86a83fba973b7425530a4f2ec42dc.png"></h4><h4 id="获取tokens"><a href="#获取tokens" class="headerlink" title="获取tokens"></a>获取tokens</h4><ul><li><p>进入个人设置页面，依次选择<code>developer settings</code> –&gt; <code>Personal access tokens</code>，然后点击<code>Generate new token</code>，来生成新的<strong>tokens</strong>，<strong>tokens</strong>也就是令牌，在图床上传时验证身份用的。</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/841c2e32b899008fe669660dd48c8482.png"></p></li><li><p>添加描述，把<strong>repo</strong>选上。</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/844576182d07e155d1ac326bbd94357b.png"></p></li><li><p>保存生成的字符串</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/2eff0418ce953cef4c970df24c2a4023.png"></p></li></ul><h3 id="picgo配置"><a href="#picgo配置" class="headerlink" title="picgo配置"></a>picgo配置</h3><h4 id="pico-插件"><a href="#pico-插件" class="headerlink" title="pico 插件"></a>pico 插件</h4><ul><li><p>首先，要借助<strong>vscode</strong>，在 <strong>vscode</strong> 中点击扩展(快捷鍵<code>crtrl</code>+<code>shift</code>+<code>X</code>)，搜索picgo安装下载<img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/3332.png" alt="picgo插件"></p></li><li><p>在设置中配置<strong>picgo</strong>，在vscode设置界面搜索picgo，具体的配置如下：</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/Snipaste_2023-02-28_16-40-02.png"></p><ul><li><p><strong>Current</strong>设置<strong>GitHub</strong>，</p></li><li><p><strong>Branch</strong>就是仓库分支，默认设置<strong>main</strong>，</p></li><li><p><strong>custom url</strong>就是我们仓库的分支，这里有两种方式可以使用：</p><ol><li><p>原生方式，弊端就是国内的访问速度比较慢</p><p>xxxxxxxxxx git push -u origin main #第一次提交加上-u参数，后续不需要git</p><p>eg：<a href="https://raw.githubusercontent.com/LKFhnust18/picgo/main">https://raw.githubusercontent.com/LKFhnust18/picgo/main</a></p></li><li><p>cdn加速方式，国内的访问速度比较快</p><p>格式为：<a href="https://cdn.jsdelivr.net/gh/[%E7%94%A8%E6%88%B7%E5%90%8D]/[%E4%BB%93%E5%BA%93%E5%90%8D]@[%E5%88%86%E6%94%AF%E5%90%8D]">https://cdn.jsdelivr.net/gh/[用户名]/[仓库名]@[分支名]</a></p><p>eg：<a href="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main">https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main</a></p></li></ol></li><li><p><strong>path</strong>就是我们的图片存储在仓库中的路径，eg：img&#x2F;</p></li><li><p><strong>repo</strong>就是我们的仓库</p></li><li><p><strong>Token</strong>，即GitHub中获取的Tokens</p></li></ul></li><li><p>上传方式：进入vscode，在你想要复制的地方使用快捷键【<code>ctrl+alt+U</code>】从剪贴板上粘贴图片，[<code>ctrl</code>+<code>alt</code>+<code>U</code>]打开资源管理器，选择图片上传。</p></li></ul><h4 id="picgo（app"><a href="#picgo（app" class="headerlink" title="picgo（app)"></a>picgo（app)</h4><p>这个可以结合<strong>Typora</strong>使用，下面是picgo的具体配置图</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/Snipaste_2023-02-28_16-44-34.png"></p><p>在typora中的配置图</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/Snipaste_2023-02-28_16-46-33.png"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu安装node.js和npm</title>
      <link href="/2023/02/28/Ubuntu%E5%AE%89%E8%A3%85node-js%E5%92%8Cnpm/"/>
      <url>/2023/02/28/Ubuntu%E5%AE%89%E8%A3%85node-js%E5%92%8Cnpm/</url>
      
        <content type="html"><![CDATA[<h2 id="Ubuntu安装node-js和npm"><a href="#Ubuntu安装node-js和npm" class="headerlink" title="Ubuntu安装node.js和npm"></a>Ubuntu安装node.js和npm</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Node.js是一个跨平台的JavaScript运行环境，它构建在 为了服务器端运行JavaScript代码而设计的Chrome JavaScript上，它通常被用来构建后端应用，但它是非常流行的全栈和前端解决方案。npm是node.js的默认包管理工具，也是世界上最大的软件仓库。下面记录Ubuntu安装node.js和npm三种不同的方式。</p><h3 id="从Ubuntu软件源安装node-js和npm"><a href="#从Ubuntu软件源安装node-js和npm" class="headerlink" title="从Ubuntu软件源安装node.js和npm"></a>从Ubuntu软件源安装node.js和npm</h3><ul><li>更新软件包索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><ul><li>安装node.js和npm</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install node.js npm   #这一条命令会自动安装一系列包，包括编译和安装npm的本地扩展</span><br></pre></td></tr></table></figure><ul><li>验证是否安装成功</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.js -version#查看node.js的版本</span><br><span class="line">npm -version #查看npm的版本</span><br></pre></td></tr></table></figure><h3 id="从NodeSource中安装Node-js和npm"><a href="#从NodeSource中安装Node-js和npm" class="headerlink" title="从NodeSource中安装Node.js和npm"></a>从NodeSource中安装Node.js和npm</h3><p>NodeSource是一家公司，提供企业级的Node支持。它维护了一个APT软件源，其中包含了很多node.js版本。如果你的应用需要制定版本的Node.js版本，就可以使用这个软件源。比如这里我们安装14.x的node.js版本：</p><ul><li>以sudo用户的身份运行下面的命令，运行安装NodeSource的安装脚本。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_14.X | sudo -E bash -</span><br></pre></td></tr></table></figure><p>这个脚本会添加NodeSource的签名key到你的系统，创建一个apt源文件，安装必备的软件包，并刷新apt缓存。</p><ul><li>NodeSource源启动成功后，安装node.js和npm</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install node.js#这个nide.js安装包同时包含node.js和npm</span><br></pre></td></tr></table></figure><ul><li>验证Node.js和npm是否正常安装，打印它们的版本号：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node --version</span><br><span class="line">npm --version</span><br></pre></td></tr></table></figure><p>如果想从npm编译本地扩展，你需要安装开发工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure><h3 id="从NVM安装node-js和npm"><a href="#从NVM安装node-js和npm" class="headerlink" title="从NVM安装node.js和npm"></a>从NVM安装node.js和npm</h3><p>NVM（Node Version Manger）是一个Bash脚本，它允许你为每一个用户管理多个Node.js版本。使用NVM，你可以随时安装或者卸载任何想要的使用或者测试的Node.js版本</p><ul><li>浏览nvm页面，并且拷贝下面的curl或者wget命令去下载和nvm版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash</span><br></pre></td></tr></table></figure><p>不要使用sudo运行，因为root用户会启用nvm</p><ul><li>验证nvm是否被正确安装，输入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm --version</span><br></pre></td></tr></table></figure><ul><li>获取node.js版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm list-remote</span><br></pre></td></tr></table></figure><ul><li>安装node</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm install node#安装最新版的node</span><br><span class="line">nvm install --lts#安装最新的长期版本node</span><br><span class="line">nvm install 10.9.0#安装版本10.9.0</span><br></pre></td></tr></table></figure><ul><li>输出已安装的node版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls</span><br></pre></td></tr></table></figure><ul><li>修改当前使用的版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use 12.16.3</span><br></pre></td></tr></table></figure><ul><li>修改默认的node.js版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm alias default 12.16.3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java的常用类</title>
      <link href="/2023/02/14/java%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
      <url>/2023/02/14/java%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="包装类的分类"><a href="#包装类的分类" class="headerlink" title="包装类的分类"></a>包装类的分类</h3><p>1.针对八种基本数据类型相应的引用数据类型——包装类（Wrapper）<br>2.有了类的特点，就可以调用类中的方法</p><table><thead><tr><th align="center">基本类型</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">Boolean</td></tr><tr><td align="center">char</td><td align="center">Character</td></tr><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr></tbody></table><h3 id="包装类和基本数据的转换"><a href="#包装类和基本数据的转换" class="headerlink" title="包装类和基本数据的转换"></a>包装类和基本数据的转换</h3><h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><p>（1）JDK前的手动装箱和拆箱方式，装箱：基本类型——&gt;包装类型，反之，拆箱。</p><p>（2）JDK5以后（包含JDK5）的自动装箱和拆箱方式</p><p>（3）自动装箱底层调用的是valueOf方法，比如Integer.valueOf()；</p><p>通过一个Integer实例理解上述内容（其他的包装类类似）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//演示int&lt;--&gt;Integer 的装箱和拆箱</span></span><br><span class="line">       <span class="comment">//JDK5以前是手动装箱和拆箱</span></span><br><span class="line">       <span class="comment">//手动装箱  int-&gt;Integer</span></span><br><span class="line">       <span class="type">int</span> n1=<span class="number">100</span>;</span><br><span class="line">       <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n1);<span class="comment">//手动装箱</span></span><br><span class="line">       Integer integer1=Integer.valueOf(n1);<span class="comment">//或者这种</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//手动拆箱</span></span><br><span class="line">       <span class="comment">//integer-&gt;int</span></span><br><span class="line">       <span class="type">int</span> n2=integer.intValue();</span><br><span class="line">       System.out.println(n2);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//JDK5以后，就可以自动装箱和自动拆箱</span></span><br><span class="line">       <span class="type">int</span> n3=<span class="number">200</span>;</span><br><span class="line">       <span class="comment">//自动装箱 Integer-&gt;int</span></span><br><span class="line">       Integer integer2=n3;   <span class="comment">//底层使用的是 Integer.valueOf(n3)方法</span></span><br><span class="line">    <span class="type">int</span> n4=integer2.intValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里有一个经典问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj1=<span class="literal">true</span>?<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>):<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(obj1);</span><br></pre></td></tr></table></figure><p>这里<strong>obj1</strong> 输出的是<strong>1.0</strong>，这是因为三元运算符是一个整体。</p><h4 id="包装类型和String类型的转换"><a href="#包装类型和String类型的转换" class="headerlink" title="包装类型和String类型的转换"></a>包装类型和String类型的转换</h4><p>这里以Integer和String转换为例，其他类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类(Integer)-&gt;String</span></span><br><span class="line">       Integer i=<span class="number">100</span>;</span><br><span class="line">       <span class="comment">//方式一</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="comment">//方式二</span></span><br><span class="line">       String str2=i.toString();</span><br><span class="line">       <span class="comment">//方式三</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//String-&gt;包装类(Integer)</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">       Integer i2=Integer.parseInt(str4);  <span class="comment">//返回的是int类型，但是使用了自动装箱</span></span><br><span class="line">       <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(str4);</span><br></pre></td></tr></table></figure><p>Character的几个常用方法</p><ul><li>isDigit(‘a’)， 判断是不是数字</li><li>isLetter(‘a’)，判断是不是字母</li><li>isUpperCase(‘a’)，判断是不是大写</li><li>isLowerCase(‘a’)，判断是不是小写</li><li>isWhitespace(‘a’)，判断是不是空格</li><li>toUpperCase(‘a’)，&#x2F;&#x2F;转成大写</li><li>toLowerCase(“A”)，转成小写</li></ul><p>Integer的一个面试题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(i==j);<span class="comment">//F</span></span><br><span class="line"></span><br><span class="line">Integer m=<span class="number">1</span>;</span><br><span class="line">Integer n=<span class="number">1</span>;</span><br><span class="line">System.out.println(m==n);<span class="comment">//T</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(x==y);<span class="comment">//F</span></span><br></pre></td></tr></table></figure><p>之所以会出现上述结果的原因是第一个是new出来的，所以i和j是两个不同的对象。第二个和第三个不同的原因是根据Integer的源码，取值范围在<strong>IntegerCache.low(-128)<strong>到</strong>IntegerCache(127)<strong>之间的就是直接返回，而超过这个范围就直接</strong>new</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String类的理解和创建对象"><a href="#String类的理解和创建对象" class="headerlink" title="String类的理解和创建对象"></a>String类的理解和创建对象</h3><p>（1）String对象用于保存字符串，也就是yyi一组字符串序列。</p><p>（2）字符串常量对象是英文双引号括起的字符串序列。例如：”你好”、”12.97”、”girl”等。</p><p>（3）字符串的字符是使用Unicode字符编码，一个字符（不区分字母还是汉字）占两个字节</p><p>（4）String类常用的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(String original);</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a,<span class="type">int</span> startIndex,<span class="type">int</span> count);</span><br></pre></td></tr></table></figure><p>分析String的源码我们可以发现以下几点：</p><p>①String类实现了<strong>Serializable</strong>说明String是串行化的，可以在在网络中传输。</p><p>②实现了<strong>Comparable</strong>y说明String对象可以相互比较。</p><p>③String是final类，不能被其他的类继承</p><p>④String有属性：<code>private final char value[]</code>用于存放字符串内，这个value因为是final类型，所以不可修改，这里指的是它的地址。</p><h3 id="创建String对象的两种方式"><a href="#创建String对象的两种方式" class="headerlink" title="创建String对象的两种方式"></a>创建String对象的两种方式</h3><p>（1）方式一：直接赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1=<span class="string">&quot;girl&quot;</span>;</span><br></pre></td></tr></table></figure><p>此方法：先从常量池查看是否有”girl”的数据空间，如果有，直接指向; 如果没有则重新创建，然后指向。str1最终指向的是常量池的空间地址。<br>（2）方式二：调用构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;girl&quot;</span>);</span><br></pre></td></tr></table></figure><p>先在堆中创建空间，里面维护了value属性，指向常亮池的girl空间。如果常量池中没有”girl”，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim快速入门</title>
      <link href="/2023/02/12/vim%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2023/02/12/vim%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="vim快速入门"><a href="#vim快速入门" class="headerlink" title="vim快速入门"></a>vim快速入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Linux内置vi文本编辑器，而vim可以看成vi的增强版。它的代码补充、编译以及错误跳转等方便编程的功能非常丰富。vi和vim有三种模式：</p><ul><li>正常模式</li><li>插入模式</li><li>命令行模式</li></ul><h3 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h3><p>用vim打开一个文件就直接进入一般模式了（就是默认模式），在这个模式中你可以使用【<code>上下左右</code>】按键来移动光标，也可以使用【<code>删除字符</code>】或者【<code>删除整行</code>】来处理文档，也可以使用复制粘贴来处理你的文档。</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/67tool.gif" alt="正常模式"></p><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><p>按下<code>i</code>、<code>I</code>、<code>o</code>、<code>O</code>、<code>a</code>、<code>A</code>、<code>r</code>、<code>R</code>等任意一个字母之后才会进入编辑模式，一般来说按<strong>i</strong>即可。</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/Snipaste_2023-03-02_17-13-02.png" alt="插入模式"></p><h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><p>在这个模式中，可以提供你相关指令、完成读取、存盘、替补、离开vim、显示行号等级别</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/Snipaste_2023-03-02_16-25-10%20.png" alt="命令行模式"></p><h3 id="vi和vim的各个模式之间的切换"><a href="#vi和vim的各个模式之间的切换" class="headerlink" title="vi和vim的各个模式之间的切换"></a>vi和vim的各个模式之间的切换</h3><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/vim-vi.png" alt="vi和vim的各个模式切换图"></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux的目录结构</title>
      <link href="/2023/02/10/linux%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2023/02/10/linux%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h2><p>Linux采用的是极层式的树状目录结构，在此结构中最上层的是根目录“&#x2F;”，然后在此目录下再创建其他的目录。Linux中有一句话：在Linux的世界里面，一切皆文件。</p><p>具体的目录结构如下</p><h3 id="x2F-bin"><a href="#x2F-bin" class="headerlink" title="&#x2F;bin"></a>&#x2F;bin</h3><p>[常用]（&#x2F;usr&#x2F;bin、&#x2F;usr&#x2F;local&#x2F;bin），bin是Binary的缩写，这个目录存放着经常使用的命令。</p><h3 id="x2F-sbin"><a href="#x2F-sbin" class="headerlink" title="&#x2F;sbin"></a>&#x2F;sbin</h3><p>(&#x2F;usr&#x2F;sbin、usr&#x2F;local&#x2F;sbin)，s就是super User的意思，这里存放的是系统管理员使用的系统管理程序。</p><h3 id="x2F-home"><a href="#x2F-home" class="headerlink" title="&#x2F;home"></a>&#x2F;home</h3><p>[常用]存放普通用户的主目录，在 Linux中每一个用户都有一个自己的一个自己的目录，一般目录是以用户的账号名命名。</p><h3 id="x2F-root"><a href="#x2F-root" class="headerlink" title="&#x2F;root"></a>&#x2F;root</h3><p>该目录为系统管理员，也称作超级用户权限者的用户主目录。</p><h3 id="x2F-etc"><a href="#x2F-etc" class="headerlink" title="&#x2F;etc"></a>&#x2F;etc</h3><p>[常用]所需的系统所需要的配置文子目录my.conf</p><h3 id="x2F-usr"><a href="#x2F-usr" class="headerlink" title="&#x2F;usr"></a>&#x2F;usr</h3><p>[常用]这是个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与widows下的program files目录。</p><h3 id="x2F-usr-x2F-local"><a href="#x2F-usr-x2F-local" class="headerlink" title="&#x2F;usr&#x2F;local"></a>&#x2F;usr&#x2F;local</h3><p>这是给主机额外安装软件所安装的目录，一般是通过编译源码的方式安装的程序。</p><h3 id="x2F-boot"><a href="#x2F-boot" class="headerlink" title="&#x2F;boot"></a>&#x2F;boot</h3><p>[常用]存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p><h3 id="x2F-proc"><a href="#x2F-proc" class="headerlink" title="&#x2F;proc"></a>&#x2F;proc</h3><p>这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。</p><h3 id="x2F-srv"><a href="#x2F-srv" class="headerlink" title="&#x2F;srv"></a>&#x2F;srv</h3><p>service缩写，该目录存放的是一些服务启动之后需要提取的数据。</p><h3 id="x2F-sys"><a href="#x2F-sys" class="headerlink" title="&#x2F;sys"></a>&#x2F;sys</h3><p>这是linux2.6内核的一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs</p><h3 id="x2F-tmp"><a href="#x2F-tmp" class="headerlink" title="&#x2F;tmp"></a>&#x2F;tmp</h3><p>这个目录是用来存放一些临时文件</p><h3 id="x2F-dev"><a href="#x2F-dev" class="headerlink" title="&#x2F;dev"></a>&#x2F;dev</h3><p>类似于Windows下的设备管理器，会把所有的硬件用文件的形式存储</p><h3 id="x2F-media"><a href="#x2F-media" class="headerlink" title="&#x2F;media"></a>&#x2F;media</h3><p>Linux会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下</p><h3 id="x2F-mnt"><a href="#x2F-mnt" class="headerlink" title="&#x2F;mnt"></a>&#x2F;mnt</h3><p>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在&#x2F;mnt&#x2F;上，然后就可以进入该目录就可以查看里面的内容了。</p><h3 id="x2F-opt"><a href="#x2F-opt" class="headerlink" title="&#x2F;opt"></a>&#x2F;opt</h3><p>这是给主机额外安装软件所摆放的目录，如安装oracle数据库就可放到该目录下面。默认为空。</p><h3 id="x2F-var"><a href="#x2F-var" class="headerlink" title="&#x2F;var"></a>&#x2F;var</h3><p>习惯将被修改的目录放在这个目录下，包括各种日志文件</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL连接Mysql报错1251——Client does not support</title>
      <link href="/2023/02/06/SQL%E8%BF%9E%E6%8E%A5Mysql%E6%8A%A5%E9%94%991251%E2%80%94%E2%80%94Client-does-not-support/"/>
      <url>/2023/02/06/SQL%E8%BF%9E%E6%8E%A5Mysql%E6%8A%A5%E9%94%991251%E2%80%94%E2%80%94Client-does-not-support/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天在新电脑上用SQLyog代替Navicat Premium，在连接Mysql数据库时候报错，上网查找解决办法后记录处理过程。</p></blockquote><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>在安装SQLyog后进行测试连接时，弹出如下提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1251 - Client does not support authentication protocol requested by server; consider upgrading MySQL Client</span><br></pre></td></tr></table></figure><p>这句话说客户端不支持服务器请求的身份验证协议；考虑升级MySQL客户端</p><h2 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h2><p>就是加密方式的问题，MySQL 8.0.11换了新的身份验证插件（caching_sha2_password)，而原来的身份验证插件为（mysql_native_password)。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>这里我们更改一下加密方式就行</p><h3 id="进入MySQL数据库"><a href="#进入MySQL数据库" class="headerlink" title="进入MySQL数据库"></a>进入MySQL数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;use mysql;</span><br></pre></td></tr></table></figure><h3 id="查看加密方式"><a href="#查看加密方式" class="headerlink" title="查看加密方式"></a>查看加密方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select user,plugin from user where user=&#x27;root&#x27;;</span><br></pre></td></tr></table></figure><h3 id="更改加密方式"><a href="#更改加密方式" class="headerlink" title="更改加密方式"></a>更改加密方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;alter user &quot;root&quot;@&quot;localhost&quot;identified with mysql_native_password by &quot;(your password)&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令简洁版总结</title>
      <link href="/2023/02/02/git%E5%91%BD%E4%BB%A4%E7%AE%80%E6%B4%81%E7%89%88%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/02/git%E5%91%BD%E4%BB%A4%E7%AE%80%E6%B4%81%E7%89%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里写一个汇总，用到就记录，反复修改，记录一些常见的 git 命令，方便自己反复浏览，[ ]表示参数。</p></blockquote><h2 id="git-配置"><a href="#git-配置" class="headerlink" title="git 配置"></a>git 配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot;#设置提交代码的用户名</span><br><span class="line">git config --global user.email &quot;exmail@example.com&quot;#设置提交代码的邮箱</span><br><span class="line">git config -l 查看当前git环境详细配置</span><br><span class="line">git config --global --list #查看当前用户配置</span><br><span class="line">git config --local --list 查看当前仓库配置信息</span><br></pre></td></tr></table></figure><h2 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init #在当前目录新建一个仓库</span><br><span class="line">git init [repository name]#在指定目录下创建一个新仓库。</span><br></pre></td></tr></table></figure><h2 id="添加到缓存区"><a href="#添加到缓存区" class="headerlink" title="添加到缓存区"></a>添加到缓存区</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add [filename/./--all]#填写filename，指定添加某个文件；git add .则是添加所有文件,但是不会记录删除操作；--all会记录删除操作，如如你在本地删除了xxx.md 这个命令会把删除信息也记录进去，然后在提交的时候把仓库里对应的xxx.md也删除掉，也就是说你在本地做的删除操作会被记录，提交仓库时会删除同样的文件。</span><br></pre></td></tr></table></figure><h2 id="提交到本地仓库"><a href="#提交到本地仓库" class="headerlink" title="提交到本地仓库"></a>提交到本地仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;info&quot; #在提交时我们需要描述一下我们做了什么，info就是我们描述的信息</span><br></pre></td></tr></table></figure><h2 id="查看历史提交日志"><a href="#查看历史提交日志" class="headerlink" title="查看历史提交日志"></a>查看历史提交日志</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline 将日志缩写为单行显示</span><br><span class="line">git log filename #查看指定文件的日志</span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit 查看分支合并情况</span><br><span class="line">git log --oneline --decorate --graph --all 查看分叉历史，包括：提交历史、各个分支的指向以及项目的分支分叉情况。</span><br><span class="line">git log -3 查看最新3条commit日志数据</span><br><span class="line">git reflog 显示操作本地版本库的命令，包括commit和reset等，在回退版本以后又后悔找不到commit id了可以使用此命令查看历史</span><br></pre></td></tr></table></figure><h2 id="回滚代码仓库-git-reset"><a href="#回滚代码仓库-git-reset" class="headerlink" title="回滚代码仓库 git reset"></a>回滚代码仓库 git reset</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard #reset是重置命令，--hard是重置代码仓库版本。这里有几种表述方式</span><br><span class="line">#1.填写哈希id，这个哈希id可以在输入git log的时候去看</span><br><span class="line">#2.回滚当前仓库指向的版本，这里有两个表达，一个是HEAD^，返回到当前仓库的上个版本；另外一个是HEAD~num，num是数字，表示以当前版本为基数，回滚num次。</span><br></pre></td></tr></table></figure><h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git status#查看所有文件状态，A：未修改AM：修改 Untracked：未提交 modified：新文件，但未提交</span><br><span class="line">git status [file-name] #查看指定文件状态</span><br><span class="line">git diff HEAD -- #查看最新本地版本库和工作区所有文件的区别</span><br><span class="line">git diff HEAD -- [file-name] #查看最新本地版本库和工作区文件的却别</span><br><span class="line">git diff HEAD^ -- [file-name] #查看本地上一个版本和工作区文件的却别</span><br><span class="line">git diff [local branch] origin/[remote branch] #比较本地分支和远程分支的区别</span><br></pre></td></tr></table></figure><h2 id="撤回最近一次修改的状态"><a href="#撤回最近一次修改的状态" class="headerlink" title="撤回最近一次修改的状态"></a>撤回最近一次修改的状态</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [url] #用于通过指定的url获取一个代码库</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm [file] #删除工作目录中的文件，并将删除操作添加到stage</span><br></pre></td></tr></table></figure><h2 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a>git show</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show [commit]#显示指定提交的元数据以及内容变更</span><br></pre></td></tr></table></figure><h2 id="分支常用命令"><a href="#分支常用命令" class="headerlink" title="分支常用命令"></a>分支常用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git branch#将会显示当前代码库中所有的本地分支</span><br><span class="line">git branch -r#列出所有远程分支：</span><br><span class="line">git branch 新分支名#新建分支，但还处于当前分支下</span><br><span class="line">git checkout -b 新分支名#新建分支并跳转到该分支下</span><br><span class="line">git merge 新分支名#合并指定分支到当前分支：</span><br><span class="line">git branch -d 分支名#删除分支：</span><br><span class="line">git push origin --delete 分支名#删除远程分支：</span><br></pre></td></tr></table></figure><h2 id="Git-连接到-GitHub"><a href="#Git-连接到-GitHub" class="headerlink" title="Git 连接到 GitHub"></a>Git 连接到 GitHub</h2><p>1.生成 ssh 密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的github邮箱&quot;</span><br></pre></td></tr></table></figure><p>2.验证是否连接成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>3.将本地的仓库连接到远程的 GitHub 仓库（如果有本地仓库）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:username/rep.git</span><br></pre></td></tr></table></figure><p>username 就是你的账户名，rep 就是你的仓库名。</p><p>4.将本地仓库更新内容推送到远程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main #第一次提交加上-u参数，后续不需要</span><br></pre></td></tr></table></figure><p>5.远程拉取新分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin &lt;远程分支名&gt;:&lt;本地分支名&gt; #只拉取不切换</span><br><span class="line">git fetch origin &lt;远程分支名&gt;  #此方式可以将远程分支拉取到本地，不能设置本地分支名，而是直接与远程分支名相同，同时切换到此分支。</span><br></pre></td></tr></table></figure><p>6.拉取代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin &lt;分支名&gt; #拉取远程分支的代码，如果有冲突就先解决冲突再提交代码</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git-bash命令</title>
      <link href="/2023/02/02/git-bash%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/02/02/git-bash%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="git-bash命令"><a href="#git-bash命令" class="headerlink" title="git-bash命令"></a>git-bash命令</h2><h3 id="git-bash简介"><a href="#git-bash简介" class="headerlink" title="git bash简介"></a>git bash简介</h3><p>在开始之前，首先了解<strong>git bash</strong>是什么？</p><blockquote><p>在windows安装<strong>git</strong>时，就会安装<strong>git bash</strong>，<strong>git bash</strong>是windows系统下的命令行工具，基于<strong>msys GNU</strong>环境，有<strong>git</strong>分布式版本控制工具。关于GNU环境，就是和<strong>Linux&#x2F;unix</strong>的环境一样，里面就是我们熟悉的linux工具，<strong>tar、grep、awk</strong>等，并且可以安装编译环境gcc、make等。</p></blockquote><h3 id="git-bash打开操作"><a href="#git-bash打开操作" class="headerlink" title="git bash打开操作"></a>git bash打开操作</h3><p>怎么打开<strong>git bash</strong>打开本地文件夹？</p><p>正常在安装<strong>git</strong>后，你可供选择方式就多了，主要有以下两种：</p><ul><li>不管在桌面找到<strong>Git bash</strong>、还是在<strong>开始</strong>里面，又或者是在搜索里面找到，点击图标就行，运行后使用<strong>cd</strong>命令，输入你想要达到的文件路径就行。(这里注意的点就是使用<strong>cd</strong>命令时使用斜线<strong>“&#x2F;”</strong>，而不是反斜线<strong>“\”</strong>)</li><li>在你想到达的文件路径里面输入<code>git bash</code>就能打开（前提是实现已经把<strong>git bash</strong>添加到<strong>path</strong> 中），又或是在文件空白区域右击选择<strong>GIt Bash Here</strong>，就能直接到你想要到达的文件路径。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/image-20230202105222112.png" alt="image-20230202105222112"></p><h3 id="git-bash常见命令"><a href="#git-bash常见命令" class="headerlink" title="git bash常见命令"></a>git bash常见命令</h3><table><thead><tr><th align="center">命令</th><th align="center"><strong>功能</strong></th></tr></thead><tbody><tr><td align="center">touch</td><td align="center">新建文件</td></tr><tr><td align="center">mkdir</td><td align="center">新建目录</td></tr><tr><td align="center">rm</td><td align="center">删除文件</td></tr><tr><td align="center">rm -r</td><td align="center">删除文件夹</td></tr><tr><td align="center">mv</td><td align="center">移动文件夹</td></tr><tr><td align="center">ls</td><td align="center">列出文件夹</td></tr><tr><td align="center">pwd</td><td align="center">打印工作目录</td></tr><tr><td align="center">cd</td><td align="center">改变目录</td></tr><tr><td align="center">reset</td><td align="center">重新初始化终端&#x2F;清屏</td></tr><tr><td align="center">history</td><td align="center">查看命令历史</td></tr><tr><td align="center">help</td><td align="center">帮助</td></tr><tr><td align="center">exit</td><td align="center">退出</td></tr></tbody></table><h3 id="git-bash常见的快捷键"><a href="#git-bash常见的快捷键" class="headerlink" title="git bash常见的快捷键"></a>git bash常见的快捷键</h3><h4 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h4><p>最简单有效的方法就是在<strong>git bash</strong>里面右击，有<code>copy和paste</code>选项。</p><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Ctrl+Shift+C或Ctrl+Insert</td><td align="center">复制</td></tr><tr><td align="center">Ctrl+Shift+S或Shift+Insert</td><td align="center">粘贴</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h4><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Home或Ctrl+A</td><td align="center">跳转至行首</td></tr><tr><td align="center">End或Ctrl+E</td><td align="center">跳转至行尾</td></tr><tr><td align="center">Ctrl+X</td><td align="center">行首&#x2F;当前位置光标跳转</td></tr></tbody></table><p>其他的没有实际用处，这里还有一个<strong>清屏</strong>的快捷键：<code>Ctrl+L</code>。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 中的集合</title>
      <link href="/2023/01/21/java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88/"/>
      <url>/2023/01/21/java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java 中的集合框架一直是 java 学习中的重中之重，以前的学习仅仅局限于皮毛，在阅读一些博客后有了新的体会，记录以便复习。</p><p>本文参考<a href="https://www.bilibili.com/video/BV1fh411y7R8?p=499">韩顺平的循序渐进学JAVA</a>、[java集合超详解](<a href="https://blog.csdn.net/feiyanaffection/article/details/81394745?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168774144216800211584849%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168774144216800211584849&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81394745-null-null.142%5Ev88%5Econtrol_2">https://blog.csdn.net/feiyanaffection/article/details/81394745?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168774144216800211584849%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168774144216800211584849&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81394745-null-null.142^v88^control_2</a>, 239^v2^insert_chatgpt&amp;utm_term&#x3D;java%E9%9B%86%E5%90%88&amp;spm&#x3D;1018.2226.3001.4187)、<a href="https://blog.csdn.net/zdl66/article/details/126251818?ops_request_misc=&request_id=&biz_id=102&utm_term=java%E9%9B%86%E5%90%88&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-126251818.nonecase&spm=1018.2226.3001.4187">java集合（超详细）</a></p></blockquote><h2 id="集合介绍"><a href="#集合介绍" class="headerlink" title="集合介绍"></a>集合介绍</h2><h3 id="集合的概述"><a href="#集合的概述" class="headerlink" title="集合的概述"></a>集合的概述</h3><p>​所有的集合类和集合接口都在 java.util 包下，</p><p>集合和数组的区别</p><p>（1）长度的区别</p><ul><li>数组长度固定，定义长了会造成内存空间的浪费，定义短了不够用。</li><li>集合可以动态保存任意多个对象，使用比较方便</li></ul><p>（2）内容的区别</p><ul><li>数组可以存储基本数据类型和引用数据类型</li><li>集合中只能是引用数据类型（存储的为对象的内存地址）</li></ul><p>（3）元素的区别</p><ul><li>数组中只能存储同一类型成员</li><li>集合中可以存储不同类型的数据（一般情况下存储的是同一类型的数据）</li></ul><h2 id="集合的框架体系"><a href="#集合的框架体系" class="headerlink" title="集合的框架体系"></a>集合的框架体系</h2><p>java 中集合的分类有很多，大致分为两类：Collection（单列集合）和 Map（双列集合），它们下面又有许多子接口。通过 intellji 的 Dragrame 功能明显可以看到 Collection 是继承于 Iterable，Set 和 list 又继承 Collection，而 ArrayList、Vector、和 LinkedList 又实现了 List 接口，HashSet、TreeSet 又实现了 Set 接口。</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/Collection.png" alt="Collection_img"></p><p>而 Map 接口下 又有 HashＭap、TreeMap、HashTbele</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/Map.png" alt="Map-img"></p><h3 id="Collection（单列集合）"><a href="#Collection（单列集合）" class="headerlink" title="Collection（单列集合）"></a>Collection（单列集合）</h3><p>（1）List 集合</p><p>​元素按先后进入顺序保存，可重复。</p><ul><li>ArrayList 接口实现类，数组，随机访问，没有同步，线程不安全</li><li>LinkedList 接口实现类，链表，插入删除，没有同步，线程不安全</li><li>Vector 接口实现类，数组，同步，线程安全<ul><li>Stack 是 Vector 接口的实现类</li></ul></li></ul><p>（2）Set 集合</p><p>​仅接收一次，不可重复，并做内部排序</p><ul><li>HashSet 使用 hash 表存储数据</li><li>TreeSet 底层实现为二叉树 ，元素排</li></ul><h2 id="Collection-的接口和方法"><a href="#Collection-的接口和方法" class="headerlink" title="Collection 的接口和方法"></a>Collection 的接口和方法</h2><p>Collection 接口实现类的特点<br>（1）Collection 实现子类可以存放多个元素，而且每个元素都可以是 Object。<br>（2）关于 Collection 的实现类，有些可以存放重复元素，有些则不可以。<br>（3）其次 Collection 的实现类，有些是有序的（List），有些不是有序的 (set)<br>（4）Collection 接口没有直接的实现子类，而是通过它的子接口（List）和（Set）来实现的。<br>这里我通过 ArrayList 来演示 Colllection 的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br></pre></td></tr></table></figure><ul><li>add 添加单个元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">list.add(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><ul><li>remove 删除指定元素，这里可以指定删除哪一个元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.remove(<span class="string">&quot;Tom&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>contains 查找元素是否存在，若元素存在则会返回 true，反之，则会返回 false.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.contains(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">list.contains(<span class="string">&quot;jack&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>size 获取元素个数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.size();</span><br></pre></td></tr></table></figure><ul><li>isEmpty: 判断是否为空</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.isEmpty();</span><br></pre></td></tr></table></figure><ul><li>clear 清空</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.clean();</span><br></pre></td></tr></table></figure><ul><li>addAll 添加多个元素，这里添加的是集合类型（Collection)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list2.add(<span class="string">&quot;三国演义&quot;</span>);</span><br><span class="line">list2.add(<span class="string">&quot;水浒传&quot;</span>);</span><br><span class="line">list.addAll(list2);<span class="comment">//直接添加的话，接在list的后面</span></span><br><span class="line">list.addAll(<span class="number">1</span>,list2);<span class="comment">//指定添加的顺序</span></span><br></pre></td></tr></table></figure><ul><li>containsAll 查找多个元素是否存在，同样参数是集合类型（Collection）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.containsAll(list2);</span><br></pre></td></tr></table></figure><ul><li>removeAll 删除多个元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.removeAll(list2);</span><br></pre></td></tr></table></figure><h2 id="Collection-接口的遍历方式"><a href="#Collection-接口的遍历方式" class="headerlink" title="Collection 接口的遍历方式"></a>Collection 接口的遍历方式</h2><h3 id="Iterator（迭代器）"><a href="#Iterator（迭代器）" class="headerlink" title="Iterator（迭代器）"></a>Iterator（迭代器）</h3><h4 id="Iterator-介绍"><a href="#Iterator-介绍" class="headerlink" title="Iterator 介绍"></a>Iterator 介绍</h4><ol><li><p>Iterator 对象称为迭代器，主要用于遍历 Collection 集合中的元素</p></li><li><p>所有实现了 Collection 接口的集合类都有一个 iterator() 方法，用来返回要给实现了 Iterator 接口的对象，既可以返回一个迭代器。</p></li><li><p>Iterator 仅用于遍历集合，Iterator 本身并不能存放对象。</p></li></ol><h4 id="迭代器的执行原理"><a href="#迭代器的执行原理" class="headerlink" title="迭代器的执行原理"></a>迭代器的执行原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line"> System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iterator 是得到的 Iterator 对象，<span style="color:blue">hasNext()</span>判断是否还有下一个元素，next 指针下移，下移后集合位置上的元素返回。</p><p>注意：在调用 iterator.next() 方法之前必须要调用 iterator.hasNext() 进行检验，若不调用，且下一条记录无效，直接调用 iterator.next() 就会抛出 NoSuchElmentException 异常。</p><p>idea 工具中快速生成迭代器的方式输入”itit“</p><h3 id="增强-for-循环"><a href="#增强-for-循环" class="headerlink" title="增强 for 循环"></a>增强 for 循环</h3><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>增强 for 循环就是简化版的 iterator，本质一样，只能用于遍历集合和数组。</p><p>基本语法</p><p>for（元素类型 元素名：集合名或数组名）{</p><p>访问元素</p><p>}</p><p>注意：</p><p>增强 for 循环底层仍然是迭代器</p><h2 id="List-接口和常用方法"><a href="#List-接口和常用方法" class="headerlink" title="List 接口和常用方法"></a>List 接口和常用方法</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>list 接口是 Collection 接口的子接口</p><p>List 集合类中的元素有序（即添加顺序和去除顺序一致），而且可以重复。</p><p>List 集合中的每一个元素都有其对应的顺序索引，即支持索引</p><h3 id="List-特有方法"><a href="#List-特有方法" class="headerlink" title="List 特有方法"></a>List 特有方法</h3><p>list 集合添加了根据索引来操作集合元素的方法</p><p>（1）void add(int index, Object obj) 在 index 的位置插入 obj 元素</p><p>（2）boolean addAll(int index, Colllection col) 从 index 位置开始将集合 col 中的所有元素添加进来</p><p>（3）Object get(int index) 获取 index 位置的元素</p><p>（4）int indexOf(Object obj) 返回 obj 在集合中首次出现的位置</p><p>（5）int lastOf(Object obj) 返回 obj 在集合中末次出现的位置</p><p>（6）Object remove(int index) 移除 index 位置的元素，并返回此元素</p><p>（7）Object set(int index, Object obj) 设置指定 index 位置的元素为 obj，相当于是置换</p><p>（8）List subList(int fromIndex, int toIndex) 返回 fromIndex 到 toIndex 位置的子集合</p><h3 id="List-的三种遍历方式"><a href="#List-的三种遍历方式" class="headerlink" title="List 的三种遍历方式"></a>List 的三种遍历方式</h3><ol><li><p>使用 Iterator</p></li><li><p>使用增强 for</p></li><li><p>使用普通 for</p></li></ol><h2 id="ArrayList-底层结构和源码分析"><a href="#ArrayList-底层结构和源码分析" class="headerlink" title="ArrayList 底层结构和源码分析"></a>ArrayList 底层结构和源码分析</h2><h3 id="ArrayList-的注意事项"><a href="#ArrayList-的注意事项" class="headerlink" title="ArrayList 的注意事项"></a>ArrayList 的注意事项</h3><p>ArrayList 可以加入 null，并且允许多个</p><p>ArrayList 是由数组来实现数据存储的</p><p>ArrayList 基本等同于 Vector，除了 ArrayList 是线程不安全的（执行效率高），多线程的情况下，不建议使用 ArrayList</p><p>add 方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    ensureCapcityInternal(size+<span class="number">1</span>);</span><br><span class="line">    elementData[size++] =e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList 扩容机制</p><ol><li><p>ArrayList 中维护了一个 Object 类型的数组 elementData.</p></li><li><p>当创建 ArrayList 对象时，如果使用的是无参构造器，则初始 elementData 容量为 0，第一次添加，则扩容 elmentData 为 10，如需要再次扩容，则扩容 elementData 为 1.5 倍。</p></li><li><p>如果使用的是指定大小的构造器，则初始 elementData 容量为指定容量大小，如果需要扩容，则直接扩容 elementData 为 1.5 倍</p></li></ol><p>第一步执行的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建了一个空的数据 elementData 数据 &#x3D;{}</p><p>第二步执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>执行 list.add</p><p>（1) 先确定是否要扩容</p><p>（2）在执行复制</p><p>再分析这个 ensureCapacityInternal() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该方法确定了 minCapacity</p><p>（1）第一次扩容为 10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>modCount 记录当前集合被修改次数，这里防止有多个线程同时去修改</p><p>minCapacity - elementData.length 当前我实际的数组的长度小于最小默认数组长度，就调用 grow() 方法去扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用扩容机制来确认要扩容到多大</p><p>第一次 newCapacity&#x3D;10</p><p>第二次以及其以后，按照 1.5 倍进行扩容</p><p>扩容使用的是 Array.copyof( )</p><p>当初始化 ArrayList 数组容量后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Vector-的基本介绍"><a href="#Vector-的基本介绍" class="headerlink" title="Vector 的基本介绍"></a>Vector 的基本介绍</h2><p>(1)Vector 类的定义说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstratList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;,RandomAccess,Cloneable,Serializable</span><br></pre></td></tr></table></figure><p>(2) Vector 底层是一个对象数组，protected Object elementData</p><p>(3) Vector 是线程同步的，即线程安全，Vector 的操作方法带有 synchronized</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> synchroized E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index&gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4) 在开发中，需要线程同步安全时，考虑使用 Vector</p><p>Vector 和 ArrayList 的比较</p><table><thead><tr><th></th><th>底层结构</th><th>线性安全，同步效率</th><th>版本</th><th>扩容倍数</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>不安全，效率高</td><td>jdk1.2</td><td>如果是有参构造，每次按 1.5 倍扩容。如果是无参构造，第一次容量变成 10，第二次按 1.5 倍扩容</td></tr><tr><td>Vector</td><td>可变数组</td><td>安全，效率不高</td><td>jdk1.0</td><td>如果是无参，默认容量为 10，满后按 2 倍扩容；如果指定大小，则每次直接按 2 倍扩容</td></tr></tbody></table><p>源码分析</p><p>无参构造：</p><p>第一步，按照默认的 10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第二步：</p><p>在使用 add 方法时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>记录操作数，然后与 ArrayList 的差不多，先确认是否需要扩容，进入<span style="color:blue">ensureCapacityHeLper</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>只有当容量满载时，才会去执行 grow 方法进行扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                        capacityIncrement : oldCapacity);</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedList-的底层机制"><a href="#LinkedList-的底层机制" class="headerlink" title="LinkedList 的底层机制"></a>LinkedList 的底层机制</h2><p>（1）Linked 底层实现了双向链表和双端队列的特点</p><p>（2）可以添加任意元素（元素可以重复），包括 null</p><p>（3）线程不安全，没有实现同步</p><p>LinkedList 的底层操作机制</p><p>（1）LinkedList 底层维护了一个双向链表</p><p>（2）LinkedList 中维护了两个属性 first 和 last 分别指向首节点和尾节点</p><p>（3）每个节点（Node 对象），里面由维护了 prey、next、item 三个属性，其中通过 prev 指向前一个，通过 next 指向后一个节点。最终实现双向链表</p><p>（4) 所以 LinkedList 的元素的添加和删除，不是通过数组完成的，相对来说效率较高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br></pre></td></tr></table></figure><p>实际上仅仅调用了它的无参构造器 <code>public LinkedList()&#123;&#125;</code> ，这时候 linkedList 的属性如下：</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/linkedList.png" alt="linkedList属性图"></p><p>下一步执行 add() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着执行，将新的节点加入到双向链表的后面，我们看一下<span style="color:blue">linkLast(e)</span>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Links e as last element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在因为现在没有节点，l&#x3D;last&#x3D;null，之后创建了一个节点 node(l, e, null)，此时，因为只有只一个节点，所以 last&#x3D;newNode，first&#x3D;newNode, </p><p>ArrayList 和 LinkedList 的比较</p><table><thead><tr><th></th><th>底层结构</th><th>增删的效率</th><th>改查的效率</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>较低，数组扩容</td><td>较高</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>较高，通过链表追加</td><td>较低</td></tr></tbody></table><p>如何选择 ArrayList 和 LinkedList：</p><p>（1）如果我们的改查的操作多，选择 ArrayList</p><p>（2）如果我们增删的操作多，选择 LinkedList</p><p>（3）一般来说，在程序中，80%~90% 都是查询，因此大部分情况下会选择 ArrayList</p><p>（4）在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是 ArrayList，另外一个模块使用是 LinkedList</p><h2 id="Set-接口和常用方法"><a href="#Set-接口和常用方法" class="headerlink" title="Set 接口和常用方法"></a>Set 接口和常用方法</h2><p>（1）无序（添加和取出的顺序不一样），没有索引</p><p>（2）不允许重复元素，所以最多包含一个 null</p><p>set 常见的方法：</p><ul><li>boolean add(E e)——如果 set 中尚未存在指定的元素，则添加此元素。</li><li>boolean addAll</li><li>clear()</li><li>contains</li><li>containsAll</li><li>equals</li><li>hashCode</li><li>isEmpty</li><li>iterator</li><li>remove</li><li>removeAll</li><li>retainAll</li><li>size</li><li>toArray</li></ul><p>HashSet 的全面说明</p><p>HashSet 实现了 Set 接口，但 HashSet 实际上是 HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以存放 null 值，不能有重复值，所以只能有一个 null</p><p>HashSet 不保证元素是有序的 m，取决于 hash 后，再确认索引的结果</p><p> 根据前面所述，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;tom&quot;</span>));<span class="comment">//true</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;tom&quot;</span>));<span class="comment">//true</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;edu&quot;</span>));<span class="comment">//true</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;edu&quot;</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>HashSet 的底层机制是数组 + 链表 + 红黑树</p><ol><li><p>先取得获取元素的哈希值（hashCode 方法）</p></li><li><p>对哈希值进行运算，得出一个索引值即为存放再哈希表中的位置号</p></li><li><p>如果该位置上没有其他元素，则直接存放。如果该位置上已经有其他元素，则需要进行 equals 判断，如果相等，则不再添加。如果不想等，则以链表的方式添加。</p></li></ol><p>HashSet 底层机制说明</p><p>分析 HashSet 的添加元素是如何实现的 (hash()+equals( ))</p><ol><li><p>HashSet 底层是 HashMap</p></li><li><p>添加一个元素时，先得到 hash 值 - 会转换成 -&gt;索引值</p></li><li><p>找到存储数据表 table，看这个索引位置是否已经存放元素</p></li><li><p>如果没有，直接加入</p></li><li><p>如果有，调用 equals 比较，如果相同，就放弃添加，如果不相同，则添加到最后</p></li><li><p>在 Java8 中，如果一条链表的元素个数超过 TREEIFY_THRESHD（默认是 8)，并且 table 的大小，并且 table 的大小》&#x3D;MIN_TREEIFY_CAPACITY（默认 64)，就会进行树化</p></li><li><p>第一步首先执行 HashSet()</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>执行 add() 方法，这里<span style="color:blue">PRESENT</span>是一个空的对象数组，用来 HashMap(Key,Vaule) 中的 Vaule 占位。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e,PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>执行 put() 方法，该方法会执行 hash(key) 方法得到 key 对应的 hash 值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key,V value)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key),key,value,<span class="literal">false</span>,<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下 hash 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>执行 putVal() 方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;<span class="comment">//定义了辅助变量</span></span><br><span class="line">    <span class="comment">//table就是放Node&lt;K,V&gt;节点的一个数组。即table就是HashMap的一个数组，类型是Node[]</span></span><br><span class="line">    <span class="comment">//if语句表示如果当前table是null，或者大小=0</span></span><br><span class="line">    <span class="comment">//就是第一次扩容到16个空间</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//(1)根据Key,得到hash，去计算该key应该存放到table表的哪一个索引位置，并且把这个位置的对象，赋给p</span></span><br><span class="line">    <span class="comment">//(2)判断p是否为空，</span></span><br><span class="line">    <span class="comment">//(2.1)如果p为空，表示还没有存放元素，就创建一个Node</span></span><br><span class="line">    <span class="comment">//(2.2)就放在该位置，tab[i]=newNode(hash,key,value,null)</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果当前索引对应的链表的第一个元素的值和要添加key的hash值相等</span></span><br><span class="line">            <span class="comment">//并且满足下面的两个条件之一</span></span><br><span class="line">            <span class="comment">//(1)准备加入的key和p指向的Node节点的key是同一个对象</span></span><br><span class="line">            <span class="comment">//(2)p指向的Node节点的key的equls()和准备加入的key比较后相同</span></span><br><span class="line">            <span class="comment">//就不能加入</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//再判断p是不是一颗红黑树</span></span><br><span class="line">            <span class="comment">//如果是一颗红黑树，就调用putTreeVal来进行添加</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//如果table对应的索引位置，已经是一个链表，就使用for循环比较</span></span><br><span class="line">                <span class="comment">//(1)依次和该链表的每一个元素比较后都不相同，则加入到该链表的最后</span></span><br><span class="line">                <span class="comment">//(2)依次和该链表的每一个元素比较过程中，如果有相同的情况，就直接break</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>hashSet 的练习思考题</p><p>定义一个 Employee 类，该类包括：private 成员属性 name，age 要求：</p><ol><li><p>创建 3 个 Employee 放入 HashSet 中</p></li><li><p>当 name 和 age 的值相同时候，认为是相同员工，不能添加到 HashSet 集合中</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql必知必会学习笔记</title>
      <link href="/2023/01/19/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/19/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库安装</title>
      <link href="/2023/01/19/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85/"/>
      <url>/2023/01/19/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL数据库安装"><a href="#MySQL数据库安装" class="headerlink" title="MySQL数据库安装"></a>MySQL数据库安装</h2><h3 id="一、下载MySQL数据库"><a href="#一、下载MySQL数据库" class="headerlink" title="一、下载MySQL数据库"></a>一、下载MySQL数据库</h3><blockquote><p>MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。Linux作为操作系统，Apache 或Nginx作为 Web 服务器，MySQL 作为数据库，PHP&#x2F;Perl&#x2F;Python作为服务器端脚本解释器，就可以建立起一个稳定、免费的网站系统，被业界称为“LAMP“或“LNMP”组合。</p></blockquote><p><strong>官网下载，MySQL官网地址：<a href="https://dev.mysql.com/downloads/installer/">https://dev.mysql.com/downloads/installer/</a></strong></p><p>进入后显示显示画面如下图，有两种下载方式：一种是在线联网安装方式，一种是离线本地安装。<br><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230117111427954-471145526.png" alt="img"><br>这里在选择<strong>Download</strong>下载后，跳转的页面会询问你是否登录，这里不用等录，直接点击<strong>No thanks,just start my download</strong><br><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230117112325608-1756119180.png" alt="img"></p><p><strong>还有一种压缩包下载方式，网址：<a href="https://dev.mysql.com/downloads/mysql/5.5.html#downloads">https://dev.mysql.com/downloads/mysql/5.5.html#downloads</a></strong></p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230117112722989-1887774282.png" alt="img"></p><h3 id="二、安装MySQL数据库"><a href="#二、安装MySQL数据库" class="headerlink" title="二、安装MySQL数据库"></a>二、安装MySQL数据库</h3><h4 id="MySQL离线本地安装包安装就是傻瓜式安装，一直next"><a href="#MySQL离线本地安装包安装就是傻瓜式安装，一直next" class="headerlink" title="MySQL离线本地安装包安装就是傻瓜式安装，一直next"></a>MySQL离线本地安装包安装就是傻瓜式安装，一直next</h4><p><strong>点击安装包界面，会弹出如下界面，这里默认配置，点击<code>next</code>就行</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230120113615870-839459251.png" alt="img"></p><p><strong>展示安装MySQL的要求，你不满足的话，按钮是<code>Execute</code>，。反之，则是<code>next</code>，点击中间按钮即可</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230120114420723-1742899806.png" alt="img"></p><p><strong>接下来<code>next</code>就行</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230120114720732-1515140083.png" alt="img"><br><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230120114746623-273742398.png" alt="img"><br><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230120114820998-1103004985.png" alt="img"></p><p><strong>然后输入 MySQL 的 root 密码，设置完密码之后点击<code>next</code>。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230120114944739-1132377535.png" alt="img"></p><p><strong>这里服务名称默认为 MySQL80,我改了服务名为</strong>MySQL<strong>，点击<code>next</code></strong></p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230120115126904-76838917.png" alt="img"></p><p><strong>安装这些配置，点击<code>Execute</code></strong></p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230120115232802-1938030.png" alt="img"></p><p><strong>这里的这些不需再继续配置，点击<code>Cancel</code>，到此MySQL安装完成</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230120115453958-554263672.png" alt="img"></p><h4 id="采用压缩包解压的安装过程如下"><a href="#采用压缩包解压的安装过程如下" class="headerlink" title="采用压缩包解压的安装过程如下"></a>采用压缩包解压的安装过程如下</h4><p><strong>解压压缩包到你想安装的路径，我这里解压的路径为C:\Program Files＼C:\Program Files\mysql-8.0.31-winx64，压缩包内文件如下</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230117113623181-1564036366.png" alt="img"></p><p><strong>配置系统环境变量，点击</strong><code>path</code> **</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230117143751961-1686532531.png" alt="img"></p><p><strong>编辑path变量,添加MySQL安装目录下bin文件的路径，我这里是C:\Program Files＼C:\Program Files\mysql-8.0.31-winx64\bin</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230117144459226-1516439253.png" alt="img"></p><p><strong>环境配置完成后，打开MySQL的安装目录，创建一个文件后缀名为.ini的my.ini空白文件</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230117144938204-2132507475.png" alt="img"></p><p><strong>编辑my.ini文件，用户初始化MySQL数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line"># 设置3306端口</span><br><span class="line">port = 3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir = D:\\mysql\\mysql-8.0.17-winx64</span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line">datadir = D:\\mysql\\mysql-8.0.17-winx64\\data</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=20</span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"># 创建模式</span><br><span class="line">sql_mode = NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br></pre></td></tr></table></figure><p><strong>在MySQL安装目录下的bin目录下的路径输入框输入cmd,并输入<code>mysqld --initialize</code>,进行初始化，然后在MySQL的安装目录下就会出现一个data的文件夹</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230117151630906-1475092417.png" alt="img"><br><strong>初始化完成后，里面生成一个.err的文件,里面含有登录mysql的密码，</strong><br><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230117151949833-2015302970.png" alt="img"><br><strong>找到root和初始root密码</strong><br><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230117152307124-1007023764.png" alt="img"><br><strong>提示</strong>：<br><strong>如果先前在电脑中安装过MySQL，请在命令行里面输入<code>sc delete mysql</code>删除之前的mysql服务</strong>。</p><p><strong>在命令行窗口输入<code>mysqld --install</code>命令，安装mysql服务</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230117153318541-415712951.png" alt="img"><br><strong>接下来，输入<code>net start mysql</code>,启动mysql服务，输入<code>mysql -uroot -p</code>，然后输入你的密码。出现如图所示算成功。</strong><br><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230117154917867-122330170.png" alt="img"><br><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo/img/3076173-20230117154938811-385295660.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己的idea配置</title>
      <link href="/2023/01/19/%E8%87%AA%E5%B7%B1%E7%9A%84idea%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/01/19/%E8%87%AA%E5%B7%B1%E7%9A%84idea%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>1.主题是<span style="color:blue">Xcode Theme</span><br>2.加载条是<span style="color:blue">Nyan Progress Bar</span><br>3.文件夹UI包<span style="color:blue">Atom Material icons</span><br>4.智慧代码提示<span style="color:blue">Tabnine AI Code Completion</span></p><h2 id="idea的快捷键"><a href="#idea的快捷键" class="headerlink" title="idea的快捷键"></a>idea的快捷键</h2><table><thead><tr><th align="center">快捷键</th><th align="center">作用</th><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td align="center">Ctrl+F9</td><td align="center">构建&#x2F;编译，相当于【buid project】</td><td>Ctrl +shift+F9</td><td>重新编译当前类</td></tr><tr><td align="center">Ctrl+d</td><td align="center">复制当前行</td><td>Ctrl+shift+c</td><td>复制选中文件路径</td></tr><tr><td align="center">Ctrl+Alt+I</td><td align="center">自动缩进行</td><td>Shift+Enter</td><td>开启新行</td></tr><tr><td align="center">Ctrl + Alt + Enter</td><td align="center">在当前行之前开始新行</td><td>Ctrl + Y</td><td>删除当前行</td></tr><tr><td align="center"><code>Ctrl + Shift + U</code></td><td align="center">大小写转换</td><td>Ctrl+Alt+Shift+Insert</td><td>创建临时文件</td></tr><tr><td align="center">Ctrl+Shift+M</td><td align="center">移动至大括号</td><td>Ctrl+[</td><td>移动到代码块开始</td></tr><tr><td align="center">Ctrl+]</td><td align="center">移动到代码块末尾</td><td>Ctrl+Space</td><td>代码补全</td></tr><tr><td align="center">Ctrl+Shift+Enter</td><td align="center">补全当前语句</td><td>Ctrl+Shift+L</td><td>格式化代码</td></tr><tr><td align="center">Ctrl+P</td><td align="center">参数信息提醒</td><td>Ctrl+Q</td><td>快速文档</td></tr><tr><td align="center">Ctrl+Alt+shift+N</td><td align="center">查找符号（变量、方法等）</td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Intellij </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的异常详解</title>
      <link href="/2023/01/18/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/01/18/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是异常"><a href="#1-什么是异常" class="headerlink" title="1.什么是异常?"></a>1.什么是异常?</h2><p>实际工作中，遇到的情况不可能是非常完美的。比如：写一个模块，用户输入的不一定符合要求，程序要打开某个文件，这个文件可能不存在或格式不对，要读数据库的数据，数据可能是空的，程序跑着，内存或者硬盘满了等等。异常指程序运行中出现的不期而至的各种情况。</p><h2 id="２-java中的异常以及分类"><a href="#２-java中的异常以及分类" class="headerlink" title="２.java中的异常以及分类"></a>２.java中的异常以及分类</h2><p>java中把异常当作对象处理，并定义了一个基类<span style="color:blue"> java.lang.Throwable </span>作为所有异常的超类。实际上java把异常分为两类:<span style="color:green">错误(error)</span>和<span style="color:blue">异常(exception)</span></p><p>Exception分支下有一个重要的子类RuntimeException(运行时异常)<br>1.ArrayIndexOutBoundsException(数组下标越界)<br>2.NullPointerException(空指针异常)<br>3.ArithmeticException(算术异常)<br>4.MissingResourceException(丢失资源)<br>5.ClassNotFoundException(找不到类)<br>这些异常是是不检查异常，程序中可以选择捕获处理，也可以不处理。</p><p>Error和Exception的区别：Error通常是灾难性的致命的错误，是程序无法控制和处理的，程序会崩溃，像: JVM系统内部错误、资源耗尽、栈溢出等。当出现这些异常时，Java虚拟机(JVM)一般会选择终止线程；Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</p><h2 id="３异常处理机制"><a href="#３异常处理机制" class="headerlink" title="３异常处理机制"></a>３异常处理机制</h2><h3 id="3-1-try-catch-finally"><a href="#3-1-try-catch-finally" class="headerlink" title="3.1 try-catch-finally"></a>3.1 try-catch-finally</h3><p><span style="color:blue">try-catch-finally</span>程序员在代码中捕获发生的异常，自行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码可能发生异常,如果异常发生了，则异常发生后面的代码不会执行，直接进入catch块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获到异常</span></span><br><span class="line"><span class="comment">     * 1.当异常发生时</span></span><br><span class="line"><span class="comment">     * 2.系统将异常封装成Exception对象e,传递给catch</span></span><br><span class="line"><span class="comment">     * 3.得到异常对象后，程序员自行处理</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//不管try代码块是否有异常发生，始终要执行finally</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">     <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">     String inputStr=<span class="string">&quot;&quot;</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">         inputStr=scanner.next();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            num = Integer.parseInt(inputStr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;你输入的不是一个整数&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-throws"><a href="#3-2-throws" class="headerlink" title="3.2 throws"></a>3.2 throws</h3><p><span style="color:blue">throws</span>将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM。</p><blockquote><p>throws后面的异常类型可以是方法中的异常类型，也可以是它的父类，也可以是异常列表，即可以抛出多个异常</p></blockquote><p>案例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//创建一个文档流对象,这里的文件找不到,显示FileNotFoundExceptionxian编译异常</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://aa.txt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">throws</span> FileNotFoundExceptionxian&#123;</span><br><span class="line">    <span class="comment">//创建一个文档流对象,这里的文件找不到,显示FileNotFoundExceptionxian编译异常</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://aa.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/Exception.png" alt="Exception"></p><h2 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="4.自定义异常"></a>4.自定义异常</h2><p>基本概念：</p><p>程序中出现了某些“错误”，但是该错误并没有在<strong>Throwable</strong>子类中描述处理，这个时候可以设计异常类，用于描述该错误信息。</p><p>在程序中使用自定义异常类，大体可以分为以下几个步骤：</p><ol><li>创建自定义异常类</li><li>在方法中通过throw关键字抛出异常对象(可以通过构造器设置信息)</li><li>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li><li>在出现异常方法的调用者中捕获并处理异常。</li></ol><p>案列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> age=<span class="number">22</span>;</span><br><span class="line">        <span class="comment">//要求年龄到20到35之间,不然抛出自定义异常</span></span><br><span class="line">        <span class="keyword">if</span>(!(age&gt;=<span class="number">20</span>&amp;&amp;age&lt;=<span class="number">35</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄需要在18到120之间&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;你的年龄需要到20到35之间&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-throw和throws的区别"><a href="#5-throw和throws的区别" class="headerlink" title="5.throw和throws的区别"></a>5.throw和throws的区别</h2><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面接</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的赋值机制</title>
      <link href="/2023/01/06/%E6%95%B0%E7%BB%84%E7%9A%84%E8%B5%8B%E5%80%BC%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/01/06/%E6%95%B0%E7%BB%84%E7%9A%84%E8%B5%8B%E5%80%BC%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数组的赋值机制"><a href="#1-数组的赋值机制" class="headerlink" title="1.数组的赋值机制"></a>1.数组的赋值机制</h2><p>基本数据类型赋值，这个值就是具体的数据，而且相互之间不影响。</p><p>eg：int n1&#x3D;2; int n2&#x3D;n1;</p><p>而对于数组而言，数组在默认情况下是引用传递，赋的值是地址。</p><p>下面通个一个案列分析数组赋值的内存图。(ArrayAssign.java)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayAssign</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//基本数据类型赋值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> n1;</span><br><span class="line">        n2 = <span class="number">80</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;n1=&quot;</span>+n1+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;n2=&quot;</span>+n2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组类型赋值</span></span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = arr1;</span><br><span class="line">        arr2[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======arr1的元素=======&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length ; i++) &#123;</span><br><span class="line">            System.out.print(arr1[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;=======arr2的元素=======&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr2.length ; i++) &#123;</span><br><span class="line">            System.out.print(arr2[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/image-20230612112919956.png" alt="image-20230612112919956"></p><p>从而我们得出了：</p><p>（1）基本数据类型赋值，赋值方式为<strong>值拷贝</strong>。所以在这里n2的变化不会影响n1的值。</p><p>（2）数组在默认情况下是<strong>引用传递</strong>，赋的是地址，所以赋值方式是地址拷贝。因为指向的是同一个地址，所以arr2的值的变化会影响到arr1。</p><p>此时的jvm内存情况如下：</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/image-20230612121108526.png" alt="image-20230612121108526"></p><p><strong>分析：</strong></p><p>运行到基本类型数据赋值时，会在栈里面开辟空间，如n1&#x3D;10。再运行到n2&#x3D;n1时它会把n1的值拷贝一份赋给n2，随后运行n2&#x3D;80时候，通过n2找到它的存储空间，把‘10’修改成‘80’，这个过程中n2的变化不会对n1造成任和影响，这个过程我们称为<strong>值传递</strong>或者叫做<strong>值拷贝</strong>。</p><p>这里进行数组赋值时，会将变量arr1指向一个空间，也就是说它没有直接指向一个值而是<strong>地址</strong>，比如说这个地址是0x0011，而这个地址指向的是堆里面的一个数据空间，如上图右边，这个空间里面分配了三个元素，分别是arr1[0]、arr1[1]、arr1[2]，此时运行到arr2&#x3D;arr1时，它会把arr1指向的地址拷贝一份给arr2，也就是说arr2也指向0x0011这个地址，即通过arr2也能访问这些元素。运行到’arr2[0]&#x3D;10’时，它会通过arr2[0]找到在堆里面分配的空间找到对应的元素，把里面的值改成10，因为arr2和arr1指向的是同一个地址，arr2修改了这个元素，那么也就直接影响到arr1的数据，所以我们将这个过程称为<strong>引用传递</strong>也叫<strong>地址拷贝</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的数组</title>
      <link href="/2023/01/05/Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"/>
      <url>/2023/01/05/Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数组介绍"><a href="#1-数组介绍" class="headerlink" title="1.数组介绍"></a>1.数组介绍</h2><ul><li>数组是相同类型数据（数据类型可以为任何类型）的有序集合，就是说数组可以存放多个同一类型的数据。</li><li>数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成</li><li>每一个数据成为一个数组元素，每个数组元素可以通过一个下标来访问他们；数组的下标从 0 开始的，下标的合法区间：[0,length-1]</li><li>数组长度的确定，不可变的。越界报错：ArrayIndexOutofBoundsException</li></ul><h2 id="2-数组的声明"><a href="#2-数组的声明" class="headerlink" title="2. 数组的声明"></a>2. 数组的声明</h2><ul><li>先声明数组变量，才使用数组<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a;   <span class="comment">//或者 </span></span><br><span class="line"><span class="type">int</span> a[];</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>使用new操作符来创建数组<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-数组的特点"><a href="#3-数组的特点" class="headerlink" title="3.数组的特点"></a>3.数组的特点</h2><p>1.长度是确定的，数组一旦被创建，它的大小就是不可以改变的。</p><p>2.元素必须是相同的类型，不允许出现混合类型</p><p>3.数组变量属于引用类型，数组也可以看成是对象，数组中 每个元素相当于该对象的成员变量</p><p>4.数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象理性，数组对象本身是在堆中的这一点可以看后面的<a href="https://lkfhnust18.github.io/LKFhnust18/2023/01/06/%E6%95%B0%E7%BB%84%E7%9A%84%E8%B5%8B%E5%80%BC%E6%9C%BA%E5%88%B6/">数组的赋值机制</a></p><h2 id="4-数组的使用"><a href="#4-数组的使用" class="headerlink" title="4.数组的使用"></a>4.数组的使用</h2><p>打印全部的数组元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array01=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array01.length;i++)&#123;</span><br><span class="line">    System.out.println(array01[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//jdk1.5之后出现增强for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> array : array01)&#123;</span><br><span class="line">    System.out.println(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反转数组元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array02=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[array02.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=result.length-<span class="number">1</span>;i&lt;array.length;i++,j--)&#123;</span><br><span class="line">    result[j]=array02[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><p>冒泡排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array03=&#123;<span class="number">32</span>,<span class="number">44</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="type">int</span> max;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array03.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;array03.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(array03[j]&gt;array03[j+<span class="number">1</span>])&#123;</span><br><span class="line">           max=array03[j];</span><br><span class="line">           array03[j]=array03[j+<span class="number">1</span>];</span><br><span class="line">           array03[j+<span class="number">1</span>]=max;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(array03);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WireShark复习以及常见的协议包抓取</title>
      <link href="/2022/01/25/WireShark%E5%A4%8D%E4%B9%A0%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%8C%85%E6%8A%93%E5%8F%96/"/>
      <url>/2022/01/25/WireShark%E5%A4%8D%E4%B9%A0%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%8C%85%E6%8A%93%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1-WireShark介绍"><a href="#1-WireShark介绍" class="headerlink" title="1.WireShark介绍"></a>1.WireShark介绍</h2><p>WireShark是一个网络包分析工具。该工具主要用来捕获网络数据包，并自动解析数据包，为用户显示数据包的详细信息，供用户对数据包进行分析。官网地址：<a href="https://www.wireshark.org/">https://www.wireshark.org/</a></p><h2 id="2-WireShark抓包原理"><a href="#2-WireShark抓包原理" class="headerlink" title="2.WireShark抓包原理"></a>2.WireShark抓包原理</h2><p>Wireshark使用的环境大致分为两种，一种是电脑直连互联网的单机环境，另外一种就是应用比较多的互联网环境，也就是连接交换机的情况。</p><p>「单机情况」下，Wireshark直接抓取本机网卡的网络流量；<br>「交换机情况」下，Wireshark通过端口镜像、ARP欺骗等方式获取局域网中的网络流量。</p><ul><li>端口镜像：利用交换机的接口，将局域网的网络流量转发到指定电脑的网卡上。</li><li>ARP欺骗：交换机根据MAC地址转发数据，伪装其他终端的MAC地址，从而获取局域网的网络流量。</li></ul><h2 id="3-WireShark快速入门"><a href="#3-WireShark快速入门" class="headerlink" title="3.WireShark快速入门"></a>3.WireShark快速入门</h2><h3 id="3-1-选择网卡"><a href="#3-1-选择网卡" class="headerlink" title="3.1.选择网卡"></a>3.1.选择网卡</h3><p>打开WireShark后，会直接进入【网卡选择界面】，如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/20230616100532.png" alt="wireshark-网卡选择"></p><p><span style="color:blue">WLAN</span>是我本地主机的无线网卡，双击网卡名，它会自动开始抓取这个网卡的流量。</p><h3 id="3-2-界面介绍以及常见操作"><a href="#3-2-界面介绍以及常见操作" class="headerlink" title="3.2 界面介绍以及常见操作"></a>3.2 界面介绍以及常见操作</h3><p>WireShark大致可以分为六个区域：</p><table><thead><tr><th>区域</th><th>功能</th></tr></thead><tbody><tr><td>菜单栏</td><td>用于调试、配置</td></tr><tr><td>快捷菜单栏(工具栏)</td><td>常用功能的快捷方式</td></tr><tr><td>过滤栏(过滤器)</td><td>定过滤条件，过滤数据包</td></tr><tr><td>数据包列表</td><td>核心区域，每一行就是一个数据包</td></tr><tr><td>数据包详情</td><td>数据包的详细数据</td></tr><tr><td>数据包字节</td><td>数据包对应的字节流，二进制</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/LKFhnust18/picgo@main/img/20230616102749.png" alt="WireShark界面"></p><p>在</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/yuanyuzhou/p/16308963.html">WireShark零基础使用教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WireShark </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
